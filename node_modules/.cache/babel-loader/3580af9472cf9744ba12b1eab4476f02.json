{"ast":null,"code":"import { parseIPv4, parseIPv6 } from \"@chainsafe/is-ip/parse\";\nimport { IPv4Len, IPv6Len, maskIp } from \"./ip.js\";\nexport function parseCidr(s) {\n  const [address, maskString] = s.split(\"/\");\n  if (!address || !maskString) throw new Error(\"Failed to parse given CIDR: \" + s);\n  let ipLength = IPv4Len;\n  let ip = parseIPv4(address);\n\n  if (ip == null) {\n    ipLength = IPv6Len;\n    ip = parseIPv6(address);\n    if (ip == null) throw new Error(\"Failed to parse given CIDR: \" + s);\n  }\n\n  const m = parseInt(maskString, 10);\n\n  if (Number.isNaN(m) || String(m).length !== maskString.length || m < 0 || m > ipLength * 8) {\n    throw new Error(\"Failed to parse given CIDR: \" + s);\n  }\n\n  const mask = cidrMask(m, 8 * ipLength);\n  return {\n    network: maskIp(ip, mask),\n    mask\n  };\n}\nexport function cidrMask(ones, bits) {\n  if (bits !== 8 * IPv4Len && bits !== 8 * IPv6Len) throw new Error(\"Invalid CIDR mask\");\n  if (ones < 0 || ones > bits) throw new Error(\"Invalid CIDR mask\");\n  const l = bits / 8;\n  const m = new Uint8Array(l);\n\n  for (let i = 0; i < l; i++) {\n    if (ones >= 8) {\n      m[i] = 0xff;\n      ones -= 8;\n      continue;\n    }\n\n    m[i] = 255 - (0xff >> ones);\n    ones = 0;\n  }\n\n  return m;\n}","map":{"version":3,"mappings":"AAAA,SAASA,SAAT,EAAoBC,SAApB,QAAqC,wBAArC;AACA,SAASC,OAAT,EAAkBC,OAAlB,EAA2BC,MAA3B,QAAyC,SAAzC;AAEA,OAAM,SAAUC,SAAV,CAAoBC,CAApB,EAA6B;AAIjC,QAAM,CAACC,OAAD,EAAUC,UAAV,IAAwBF,CAAC,CAACG,KAAF,CAAQ,GAAR,CAA9B;AACA,MAAI,CAACF,OAAD,IAAY,CAACC,UAAjB,EACE,MAAM,IAAIE,KAAJ,CAAU,iCAAiCJ,CAA3C,CAAN;AACF,MAAIK,QAAQ,GAAGT,OAAf;AACA,MAAIU,EAAE,GAAGZ,SAAS,CAACO,OAAD,CAAlB;;AACA,MAAIK,EAAE,IAAI,IAAV,EAAgB;AACdD,YAAQ,GAAGR,OAAX;AACAS,MAAE,GAAGX,SAAS,CAACM,OAAD,CAAd;AACA,QAAIK,EAAE,IAAI,IAAV,EAAgB,MAAM,IAAIF,KAAJ,CAAU,iCAAiCJ,CAA3C,CAAN;AACjB;;AACD,QAAMO,CAAC,GAAGC,QAAQ,CAACN,UAAD,EAAa,EAAb,CAAlB;;AACA,MACEO,MAAM,CAACC,KAAP,CAAaH,CAAb,KACAI,MAAM,CAACJ,CAAD,CAAN,CAAUK,MAAV,KAAqBV,UAAU,CAACU,MADhC,IAEAL,CAAC,GAAG,CAFJ,IAGAA,CAAC,GAAGF,QAAQ,GAAG,CAJjB,EAKE;AACA,UAAM,IAAID,KAAJ,CAAU,iCAAiCJ,CAA3C,CAAN;AACD;;AACD,QAAMa,IAAI,GAAGC,QAAQ,CAACP,CAAD,EAAI,IAAIF,QAAR,CAArB;AACA,SAAO;AACLU,WAAO,EAAEjB,MAAM,CAACQ,EAAD,EAAKO,IAAL,CADV;AAELA;AAFK,GAAP;AAID;AAED,OAAM,SAAUC,QAAV,CAAmBE,IAAnB,EAAiCC,IAAjC,EAA6C;AACjD,MAAIA,IAAI,KAAK,IAAIrB,OAAb,IAAwBqB,IAAI,KAAK,IAAIpB,OAAzC,EACE,MAAM,IAAIO,KAAJ,CAAU,mBAAV,CAAN;AACF,MAAIY,IAAI,GAAG,CAAP,IAAYA,IAAI,GAAGC,IAAvB,EAA6B,MAAM,IAAIb,KAAJ,CAAU,mBAAV,CAAN;AAC7B,QAAMc,CAAC,GAAGD,IAAI,GAAG,CAAjB;AACA,QAAMV,CAAC,GAAG,IAAIY,UAAJ,CAAeD,CAAf,CAAV;;AACA,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,CAApB,EAAuBE,CAAC,EAAxB,EAA4B;AAC1B,QAAIJ,IAAI,IAAI,CAAZ,EAAe;AACbT,OAAC,CAACa,CAAD,CAAD,GAAO,IAAP;AACAJ,UAAI,IAAI,CAAR;AACA;AACD;;AACDT,KAAC,CAACa,CAAD,CAAD,GAAO,OAAO,QAAQJ,IAAf,CAAP;AACAA,QAAI,GAAG,CAAP;AACD;;AACD,SAAOT,CAAP;AACD","names":["parseIPv4","parseIPv6","IPv4Len","IPv6Len","maskIp","parseCidr","s","address","maskString","split","Error","ipLength","ip","m","parseInt","Number","isNaN","String","length","mask","cidrMask","network","ones","bits","l","Uint8Array","i"],"sources":["/home/legasi/nft-marketplace/node_modules/@chainsafe/netmask/src/cidr.ts"],"sourcesContent":["import { parseIPv4, parseIPv6 } from \"@chainsafe/is-ip/parse\";\nimport { IPv4Len, IPv6Len, maskIp } from \"./ip.js\";\n\nexport function parseCidr(s: string): {\n  network: Uint8Array;\n  mask: Uint8Array;\n} {\n  const [address, maskString] = s.split(\"/\");\n  if (!address || !maskString)\n    throw new Error(\"Failed to parse given CIDR: \" + s);\n  let ipLength = IPv4Len;\n  let ip = parseIPv4(address);\n  if (ip == null) {\n    ipLength = IPv6Len;\n    ip = parseIPv6(address);\n    if (ip == null) throw new Error(\"Failed to parse given CIDR: \" + s);\n  }\n  const m = parseInt(maskString, 10);\n  if (\n    Number.isNaN(m) ||\n    String(m).length !== maskString.length ||\n    m < 0 ||\n    m > ipLength * 8\n  ) {\n    throw new Error(\"Failed to parse given CIDR: \" + s);\n  }\n  const mask = cidrMask(m, 8 * ipLength);\n  return {\n    network: maskIp(ip, mask),\n    mask,\n  };\n}\n\nexport function cidrMask(ones: number, bits: number): Uint8Array {\n  if (bits !== 8 * IPv4Len && bits !== 8 * IPv6Len)\n    throw new Error(\"Invalid CIDR mask\");\n  if (ones < 0 || ones > bits) throw new Error(\"Invalid CIDR mask\");\n  const l = bits / 8;\n  const m = new Uint8Array(l);\n  for (let i = 0; i < l; i++) {\n    if (ones >= 8) {\n      m[i] = 0xff;\n      ones -= 8;\n      continue;\n    }\n    m[i] = 255 - (0xff >> ones);\n    ones = 0;\n  }\n  return m;\n}\n"]},"metadata":{},"sourceType":"module"}