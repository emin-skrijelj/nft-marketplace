{"ast":null,"code":"import { CID } from 'multiformats/cid';\nimport { decodeNode } from './pb-decode.js';\nimport { encodeNode } from './pb-encode.js';\nimport { prepare, validate, createNode, createLink } from './util.js';\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @typedef {import('./interface.js').PBLink} PBLink\n * @typedef {import('./interface.js').PBNode} PBNode\n */\n\nexport const name = 'dag-pb';\nexport const code = 0x70;\n/**\n * @param {PBNode} node\n * @returns {ByteView<PBNode>}\n */\n\nexport function encode(node) {\n  validate(node);\n  const pbn = {};\n\n  if (node.Links) {\n    pbn.Links = node.Links.map(l => {\n      const link = {};\n\n      if (l.Hash) {\n        link.Hash = l.Hash.bytes; // cid -> bytes\n      }\n\n      if (l.Name !== undefined) {\n        link.Name = l.Name;\n      }\n\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize;\n      }\n\n      return link;\n    });\n  }\n\n  if (node.Data) {\n    pbn.Data = node.Data;\n  }\n\n  return encodeNode(pbn);\n}\n/**\n * @param {ByteView<PBNode>} bytes\n * @returns {PBNode}\n */\n\nexport function decode(bytes) {\n  const pbn = decodeNode(bytes);\n  const node = {};\n\n  if (pbn.Data) {\n    node.Data = pbn.Data;\n  }\n\n  if (pbn.Links) {\n    node.Links = pbn.Links.map(l => {\n      const link = {};\n\n      try {\n        link.Hash = CID.decode(l.Hash);\n      } catch (e) {}\n\n      if (!link.Hash) {\n        throw new Error('Invalid Hash field found in link, expected CID');\n      }\n\n      if (l.Name !== undefined) {\n        link.Name = l.Name;\n      }\n\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize;\n      }\n\n      return link;\n    });\n  }\n\n  return node;\n}\nexport { prepare, validate, createNode, createLink };","map":{"version":3,"sources":["/home/legasi/nft-marketplace/node_modules/@ipld/dag-pb/src/index.js"],"names":["CID","decodeNode","encodeNode","prepare","validate","createNode","createLink","name","code","encode","node","pbn","Links","map","l","link","Hash","bytes","Name","undefined","Tsize","Data","decode","e","Error"],"mappings":"AAAA,SAASA,GAAT,QAAoB,kBAApB;AACA,SAASC,UAAT,QAA2B,gBAA3B;AACA,SAASC,UAAT,QAA2B,gBAA3B;AACA,SAASC,OAAT,EAAkBC,QAAlB,EAA4BC,UAA5B,EAAwCC,UAAxC,QAA0D,WAA1D;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,IAAI,GAAG,QAAb;AACP,OAAO,MAAMC,IAAI,GAAG,IAAb;AAEP;AACA;AACA;AACA;;AACA,OAAO,SAASC,MAAT,CAAiBC,IAAjB,EAAuB;AAC5BN,EAAAA,QAAQ,CAACM,IAAD,CAAR;AAEA,QAAMC,GAAG,GAAG,EAAZ;;AACA,MAAID,IAAI,CAACE,KAAT,EAAgB;AACdD,IAAAA,GAAG,CAACC,KAAJ,GAAYF,IAAI,CAACE,KAAL,CAAWC,GAAX,CAAgBC,CAAD,IAAO;AAChC,YAAMC,IAAI,GAAG,EAAb;;AACA,UAAID,CAAC,CAACE,IAAN,EAAY;AACVD,QAAAA,IAAI,CAACC,IAAL,GAAYF,CAAC,CAACE,IAAF,CAAOC,KAAnB,CADU,CACe;AAC1B;;AACD,UAAIH,CAAC,CAACI,IAAF,KAAWC,SAAf,EAA0B;AACxBJ,QAAAA,IAAI,CAACG,IAAL,GAAYJ,CAAC,CAACI,IAAd;AACD;;AACD,UAAIJ,CAAC,CAACM,KAAF,KAAYD,SAAhB,EAA2B;AACzBJ,QAAAA,IAAI,CAACK,KAAL,GAAaN,CAAC,CAACM,KAAf;AACD;;AACD,aAAOL,IAAP;AACD,KAZW,CAAZ;AAaD;;AACD,MAAIL,IAAI,CAACW,IAAT,EAAe;AACbV,IAAAA,GAAG,CAACU,IAAJ,GAAWX,IAAI,CAACW,IAAhB;AACD;;AAED,SAAOnB,UAAU,CAACS,GAAD,CAAjB;AACD;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASW,MAAT,CAAiBL,KAAjB,EAAwB;AAC7B,QAAMN,GAAG,GAAGV,UAAU,CAACgB,KAAD,CAAtB;AAEA,QAAMP,IAAI,GAAG,EAAb;;AAEA,MAAIC,GAAG,CAACU,IAAR,EAAc;AACZX,IAAAA,IAAI,CAACW,IAAL,GAAYV,GAAG,CAACU,IAAhB;AACD;;AAED,MAAIV,GAAG,CAACC,KAAR,EAAe;AACbF,IAAAA,IAAI,CAACE,KAAL,GAAaD,GAAG,CAACC,KAAJ,CAAUC,GAAV,CAAeC,CAAD,IAAO;AAChC,YAAMC,IAAI,GAAG,EAAb;;AACA,UAAI;AACFA,QAAAA,IAAI,CAACC,IAAL,GAAYhB,GAAG,CAACsB,MAAJ,CAAWR,CAAC,CAACE,IAAb,CAAZ;AACD,OAFD,CAEE,OAAOO,CAAP,EAAU,CAAE;;AACd,UAAI,CAACR,IAAI,CAACC,IAAV,EAAgB;AACd,cAAM,IAAIQ,KAAJ,CAAU,gDAAV,CAAN;AACD;;AACD,UAAIV,CAAC,CAACI,IAAF,KAAWC,SAAf,EAA0B;AACxBJ,QAAAA,IAAI,CAACG,IAAL,GAAYJ,CAAC,CAACI,IAAd;AACD;;AACD,UAAIJ,CAAC,CAACM,KAAF,KAAYD,SAAhB,EAA2B;AACzBJ,QAAAA,IAAI,CAACK,KAAL,GAAaN,CAAC,CAACM,KAAf;AACD;;AACD,aAAOL,IAAP;AACD,KAfY,CAAb;AAgBD;;AAED,SAAOL,IAAP;AACD;AAED,SAASP,OAAT,EAAkBC,QAAlB,EAA4BC,UAA5B,EAAwCC,UAAxC","sourcesContent":["import { CID } from 'multiformats/cid'\nimport { decodeNode } from './pb-decode.js'\nimport { encodeNode } from './pb-encode.js'\nimport { prepare, validate, createNode, createLink } from './util.js'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @typedef {import('./interface.js').PBLink} PBLink\n * @typedef {import('./interface.js').PBNode} PBNode\n */\n\nexport const name = 'dag-pb'\nexport const code = 0x70\n\n/**\n * @param {PBNode} node\n * @returns {ByteView<PBNode>}\n */\nexport function encode (node) {\n  validate(node)\n\n  const pbn = {}\n  if (node.Links) {\n    pbn.Links = node.Links.map((l) => {\n      const link = {}\n      if (l.Hash) {\n        link.Hash = l.Hash.bytes // cid -> bytes\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n  if (node.Data) {\n    pbn.Data = node.Data\n  }\n\n  return encodeNode(pbn)\n}\n\n/**\n * @param {ByteView<PBNode>} bytes\n * @returns {PBNode}\n */\nexport function decode (bytes) {\n  const pbn = decodeNode(bytes)\n\n  const node = {}\n\n  if (pbn.Data) {\n    node.Data = pbn.Data\n  }\n\n  if (pbn.Links) {\n    node.Links = pbn.Links.map((l) => {\n      const link = {}\n      try {\n        link.Hash = CID.decode(l.Hash)\n      } catch (e) {}\n      if (!link.Hash) {\n        throw new Error('Invalid Hash field found in link, expected CID')\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n\n  return node\n}\n\nexport { prepare, validate, createNode, createLink }\n"]},"metadata":{},"sourceType":"module"}