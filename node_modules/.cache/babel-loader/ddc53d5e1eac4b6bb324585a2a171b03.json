{"ast":null,"code":"export const useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === 'function';\nconst textDecoder = new TextDecoder();\nconst textEncoder = new TextEncoder();\n\nfunction isBuffer(buf) {\n  return useBuffer && globalThis.Buffer.isBuffer(buf);\n}\n\nexport function asU8A(buf) {\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf);\n  }\n\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf;\n}\nexport const toString = useBuffer ? (bytes, start, end) => {\n  return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8') : utf8Slice(bytes, start, end);\n} : (bytes, start, end) => {\n  return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);\n};\nexport const fromString = useBuffer ? string => {\n  return string.length > 64 ? globalThis.Buffer.from(string) : utf8ToBytes(string);\n} : string => {\n  return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string);\n};\nexport const fromArray = arr => {\n  return Uint8Array.from(arr);\n};\nexport const slice = useBuffer ? (bytes, start, end) => {\n  if (isBuffer(bytes)) {\n    return new Uint8Array(bytes.subarray(start, end));\n  }\n\n  return bytes.slice(start, end);\n} : (bytes, start, end) => {\n  return bytes.slice(start, end);\n};\nexport const concat = useBuffer ? (chunks, length) => {\n  chunks = chunks.map(c => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));\n  return asU8A(globalThis.Buffer.concat(chunks, length));\n} : (chunks, length) => {\n  const out = new Uint8Array(length);\n  let off = 0;\n\n  for (let b of chunks) {\n    if (off + b.length > out.length) {\n      b = b.subarray(0, out.length - off);\n    }\n\n    out.set(b, off);\n    off += b.length;\n  }\n\n  return out;\n};\nexport const alloc = useBuffer ? size => {\n  return globalThis.Buffer.allocUnsafe(size);\n} : size => {\n  return new Uint8Array(size);\n};\nexport const toHex = useBuffer ? d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n\n  return globalThis.Buffer.from(toBytes(d)).toString('hex');\n} : d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n\n  return Array.prototype.reduce.call(toBytes(d), (p, c) => `${p}${c.toString(16).padStart(2, '0')}`, '');\n};\nexport const fromHex = useBuffer ? hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n\n  return globalThis.Buffer.from(hex, 'hex');\n} : hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n\n  if (!hex.length) {\n    return new Uint8Array(0);\n  }\n\n  return new Uint8Array(hex.split('').map((c, i, d) => i % 2 === 0 ? `0x${c}${d[i + 1]}` : '').filter(Boolean).map(e => parseInt(e, 16)));\n};\n\nfunction toBytes(obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj;\n  }\n\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj);\n  }\n\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);\n  }\n\n  throw new Error('Unknown type, must be binary type');\n}\n\nexport function compare(b1, b2) {\n  if (isBuffer(b1) && isBuffer(b2)) {\n    return b1.compare(b2);\n  }\n\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue;\n    }\n\n    return b1[i] < b2[i] ? -1 : 1;\n  }\n\n  return 0;\n}\n\nfunction utf8ToBytes(string) {\n  let units = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n  let codePoint;\n  const length = string.length;\n  let leadSurrogate = null;\n  const bytes = [];\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n\n    if (codePoint > 55295 && codePoint < 57344) {\n      if (!leadSurrogate) {\n        if (codePoint > 56319) {\n          if ((units -= 3) > -1) bytes.push(239, 191, 189);\n          continue;\n        } else if (i + 1 === length) {\n          if ((units -= 3) > -1) bytes.push(239, 191, 189);\n          continue;\n        }\n\n        leadSurrogate = codePoint;\n        continue;\n      }\n\n      if (codePoint < 56320) {\n        if ((units -= 3) > -1) bytes.push(239, 191, 189);\n        leadSurrogate = codePoint;\n        continue;\n      }\n\n      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n    } else if (leadSurrogate) {\n      if ((units -= 3) > -1) bytes.push(239, 191, 189);\n    }\n\n    leadSurrogate = null;\n\n    if (codePoint < 128) {\n      if ((units -= 1) < 0) break;\n      bytes.push(codePoint);\n    } else if (codePoint < 2048) {\n      if ((units -= 2) < 0) break;\n      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n    } else if (codePoint < 65536) {\n      if ((units -= 3) < 0) break;\n      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else if (codePoint < 1114112) {\n      if ((units -= 4) < 0) break;\n      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n\n  return bytes;\n}\n\nfunction utf8Slice(buf, offset, end) {\n  const res = [];\n\n  while (offset < end) {\n    const firstByte = buf[offset];\n    let codePoint = null;\n    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 128) {\n            codePoint = firstByte;\n          }\n\n          break;\n\n        case 2:\n          secondByte = buf[offset + 1];\n\n          if ((secondByte & 192) === 128) {\n            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n\n            if (tempCodePoint > 127) {\n              codePoint = tempCodePoint;\n            }\n          }\n\n          break;\n\n        case 3:\n          secondByte = buf[offset + 1];\n          thirdByte = buf[offset + 2];\n\n          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n\n            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n              codePoint = tempCodePoint;\n            }\n          }\n\n          break;\n\n        case 4:\n          secondByte = buf[offset + 1];\n          thirdByte = buf[offset + 2];\n          fourthByte = buf[offset + 3];\n\n          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n\n            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n              codePoint = tempCodePoint;\n            }\n          }\n\n      }\n    }\n\n    if (codePoint === null) {\n      codePoint = 65533;\n      bytesPerSequence = 1;\n    } else if (codePoint > 65535) {\n      codePoint -= 65536;\n      res.push(codePoint >>> 10 & 1023 | 55296);\n      codePoint = 56320 | codePoint & 1023;\n    }\n\n    res.push(codePoint);\n    offset += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res);\n}\n\nconst MAX_ARGUMENTS_LENGTH = 4096;\nexport function decodeCodePointsArray(codePoints) {\n  const len = codePoints.length;\n\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints);\n  }\n\n  let res = '';\n  let i = 0;\n\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n\n  return res;\n}","map":{"version":3,"sources":["/home/legasi/nft-marketplace/node_modules/cborg/esm/lib/byte-utils.js"],"names":["useBuffer","globalThis","process","browser","Buffer","isBuffer","textDecoder","TextDecoder","textEncoder","TextEncoder","buf","asU8A","Uint8Array","from","buffer","byteOffset","byteLength","toString","bytes","start","end","subarray","utf8Slice","decode","fromString","string","length","utf8ToBytes","encode","fromArray","arr","slice","concat","chunks","map","c","out","off","b","set","alloc","size","allocUnsafe","toHex","d","toBytes","Array","prototype","reduce","call","p","padStart","fromHex","hex","split","i","filter","Boolean","e","parseInt","obj","constructor","name","ArrayBuffer","isView","Error","compare","b1","b2","units","Infinity","codePoint","leadSurrogate","charCodeAt","push","offset","res","firstByte","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","MAX_ARGUMENTS_LENGTH","codePoints","len","String","fromCharCode","apply"],"mappings":"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","sourcesContent":["export const useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === 'function';\nconst textDecoder = new TextDecoder();\nconst textEncoder = new TextEncoder();\nfunction isBuffer(buf) {\n  return useBuffer && globalThis.Buffer.isBuffer(buf);\n}\nexport function asU8A(buf) {\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf);\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf;\n}\nexport const toString = useBuffer ? (bytes, start, end) => {\n  return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8') : utf8Slice(bytes, start, end);\n} : (bytes, start, end) => {\n  return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);\n};\nexport const fromString = useBuffer ? string => {\n  return string.length > 64 ? globalThis.Buffer.from(string) : utf8ToBytes(string);\n} : string => {\n  return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string);\n};\nexport const fromArray = arr => {\n  return Uint8Array.from(arr);\n};\nexport const slice = useBuffer ? (bytes, start, end) => {\n  if (isBuffer(bytes)) {\n    return new Uint8Array(bytes.subarray(start, end));\n  }\n  return bytes.slice(start, end);\n} : (bytes, start, end) => {\n  return bytes.slice(start, end);\n};\nexport const concat = useBuffer ? (chunks, length) => {\n  chunks = chunks.map(c => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));\n  return asU8A(globalThis.Buffer.concat(chunks, length));\n} : (chunks, length) => {\n  const out = new Uint8Array(length);\n  let off = 0;\n  for (let b of chunks) {\n    if (off + b.length > out.length) {\n      b = b.subarray(0, out.length - off);\n    }\n    out.set(b, off);\n    off += b.length;\n  }\n  return out;\n};\nexport const alloc = useBuffer ? size => {\n  return globalThis.Buffer.allocUnsafe(size);\n} : size => {\n  return new Uint8Array(size);\n};\nexport const toHex = useBuffer ? d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return globalThis.Buffer.from(toBytes(d)).toString('hex');\n} : d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return Array.prototype.reduce.call(toBytes(d), (p, c) => `${ p }${ c.toString(16).padStart(2, '0') }`, '');\n};\nexport const fromHex = useBuffer ? hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  return globalThis.Buffer.from(hex, 'hex');\n} : hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  if (!hex.length) {\n    return new Uint8Array(0);\n  }\n  return new Uint8Array(hex.split('').map((c, i, d) => i % 2 === 0 ? `0x${ c }${ d[i + 1] }` : '').filter(Boolean).map(e => parseInt(e, 16)));\n};\nfunction toBytes(obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj;\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj);\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n}\nexport function compare(b1, b2) {\n  if (isBuffer(b1) && isBuffer(b2)) {\n    return b1.compare(b2);\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue;\n    }\n    return b1[i] < b2[i] ? -1 : 1;\n  }\n  return 0;\n}\nfunction utf8ToBytes(string, units = Infinity) {\n  let codePoint;\n  const length = string.length;\n  let leadSurrogate = null;\n  const bytes = [];\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n    if (codePoint > 55295 && codePoint < 57344) {\n      if (!leadSurrogate) {\n        if (codePoint > 56319) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          continue;\n        } else if (i + 1 === length) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          continue;\n        }\n        leadSurrogate = codePoint;\n        continue;\n      }\n      if (codePoint < 56320) {\n        if ((units -= 3) > -1)\n          bytes.push(239, 191, 189);\n        leadSurrogate = codePoint;\n        continue;\n      }\n      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n    } else if (leadSurrogate) {\n      if ((units -= 3) > -1)\n        bytes.push(239, 191, 189);\n    }\n    leadSurrogate = null;\n    if (codePoint < 128) {\n      if ((units -= 1) < 0)\n        break;\n      bytes.push(codePoint);\n    } else if (codePoint < 2048) {\n      if ((units -= 2) < 0)\n        break;\n      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n    } else if (codePoint < 65536) {\n      if ((units -= 3) < 0)\n        break;\n      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else if (codePoint < 1114112) {\n      if ((units -= 4) < 0)\n        break;\n      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n  return bytes;\n}\nfunction utf8Slice(buf, offset, end) {\n  const res = [];\n  while (offset < end) {\n    const firstByte = buf[offset];\n    let codePoint = null;\n    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint;\n      switch (bytesPerSequence) {\n      case 1:\n        if (firstByte < 128) {\n          codePoint = firstByte;\n        }\n        break;\n      case 2:\n        secondByte = buf[offset + 1];\n        if ((secondByte & 192) === 128) {\n          tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n          if (tempCodePoint > 127) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 3:\n        secondByte = buf[offset + 1];\n        thirdByte = buf[offset + 2];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n          if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 4:\n        secondByte = buf[offset + 1];\n        thirdByte = buf[offset + 2];\n        fourthByte = buf[offset + 3];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n          if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n            codePoint = tempCodePoint;\n          }\n        }\n      }\n    }\n    if (codePoint === null) {\n      codePoint = 65533;\n      bytesPerSequence = 1;\n    } else if (codePoint > 65535) {\n      codePoint -= 65536;\n      res.push(codePoint >>> 10 & 1023 | 55296);\n      codePoint = 56320 | codePoint & 1023;\n    }\n    res.push(codePoint);\n    offset += bytesPerSequence;\n  }\n  return decodeCodePointsArray(res);\n}\nconst MAX_ARGUMENTS_LENGTH = 4096;\nexport function decodeCodePointsArray(codePoints) {\n  const len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints);\n  }\n  let res = '';\n  let i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n  return res;\n}"]},"metadata":{},"sourceType":"module"}