{"ast":null,"code":"import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { SendingQuery, PeerResponse, FinalPeer, QueryError, Provider, Value, AddingPeer, DialingPeer } from './response-types.js';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { peerIdFromString } from '@libp2p/peer-id';\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {{Type: number, ID: string, Extra: string, Responses: {ID: string, Addrs: string[]}[]}} event\n * @returns {import('ipfs-core-types/src/dht').QueryEvent}\n */\n\nexport const mapEvent = event => {\n  if (event.Type === SendingQuery) {\n    return {\n      name: 'SENDING_QUERY',\n      type: event.Type\n    };\n  }\n\n  if (event.Type === PeerResponse) {\n    return {\n      from: peerIdFromString(event.ID),\n      name: 'PEER_RESPONSE',\n      type: event.Type,\n      // TODO: how to infer this from the go-ipfs response\n      messageType: 0,\n      // TODO: how to infer this from the go-ipfs response\n      messageName: 'PUT_VALUE',\n      closer: (event.Responses || []).map(_ref => {\n        let {\n          ID,\n          Addrs\n        } = _ref;\n        return {\n          id: peerIdFromString(ID),\n          multiaddrs: Addrs.map(addr => multiaddr(addr)),\n          protocols: []\n        };\n      }),\n      providers: (event.Responses || []).map(_ref2 => {\n        let {\n          ID,\n          Addrs\n        } = _ref2;\n        return {\n          id: peerIdFromString(ID),\n          multiaddrs: Addrs.map(addr => multiaddr(addr)),\n          protocols: []\n        };\n      }) // TODO: how to infer this from the go-ipfs response\n      // record: ???\n\n    };\n  }\n\n  if (event.Type === FinalPeer) {\n    // dht.query ends with a FinalPeer event with no Responses\n\n    /** @type {import('@libp2p/interface-peer-info').PeerInfo} */\n    let peer = {\n      // @ts-expect-error go-ipfs does not return this\n      id: event.ID ?? peerIdFromString(event.ID),\n\n      /** @type {Multiaddr[]} */\n      multiaddrs: [],\n      protocols: []\n    };\n\n    if (event.Responses && event.Responses.length) {\n      // dht.findPeer has the result in the Responses field\n      peer = {\n        id: peerIdFromString(event.Responses[0].ID),\n        multiaddrs: event.Responses[0].Addrs.map(addr => multiaddr(addr)),\n        protocols: []\n      };\n    }\n\n    return {\n      name: 'FINAL_PEER',\n      type: event.Type,\n      peer\n    };\n  }\n\n  if (event.Type === QueryError) {\n    return {\n      name: 'QUERY_ERROR',\n      type: event.Type,\n      error: new Error(event.Extra)\n    };\n  }\n\n  if (event.Type === Provider) {\n    return {\n      name: 'PROVIDER',\n      type: event.Type,\n      providers: event.Responses.map(_ref3 => {\n        let {\n          ID,\n          Addrs\n        } = _ref3;\n        return {\n          id: peerIdFromString(ID),\n          multiaddrs: Addrs.map(addr => multiaddr(addr)),\n          protocols: []\n        };\n      })\n    };\n  }\n\n  if (event.Type === Value) {\n    return {\n      name: 'VALUE',\n      type: event.Type,\n      value: uint8ArrayFromString(event.Extra, 'base64pad')\n    };\n  }\n\n  if (event.Type === AddingPeer) {\n    const peers = event.Responses.map(_ref4 => {\n      let {\n        ID\n      } = _ref4;\n      return peerIdFromString(ID);\n    });\n\n    if (!peers.length) {\n      throw new Error('No peer found');\n    }\n\n    return {\n      name: 'ADDING_PEER',\n      type: event.Type,\n      peer: peers[0]\n    };\n  }\n\n  if (event.Type === DialingPeer) {\n    return {\n      name: 'DIALING_PEER',\n      type: event.Type,\n      peer: peerIdFromString(event.ID)\n    };\n  }\n\n  throw new Error('Unknown DHT event type');\n};","map":{"version":3,"sources":["/home/legasi/nft-marketplace/node_modules/ipfs-http-client/src/dht/map-event.js"],"names":["fromString","uint8ArrayFromString","SendingQuery","PeerResponse","FinalPeer","QueryError","Provider","Value","AddingPeer","DialingPeer","multiaddr","peerIdFromString","mapEvent","event","Type","name","type","from","ID","messageType","messageName","closer","Responses","map","Addrs","id","multiaddrs","addr","protocols","providers","peer","length","error","Error","Extra","value","peers"],"mappings":"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","sourcesContent":["import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport {\n  SendingQuery,\n  PeerResponse,\n  FinalPeer,\n  QueryError,\n  Provider,\n  Value,\n  AddingPeer,\n  DialingPeer\n} from './response-types.js'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { peerIdFromString } from '@libp2p/peer-id'\n\n/**\n * @typedef {import('@libp2p/interface-peer-id').PeerId} PeerId\n * @typedef {import('@multiformats/multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @param {{Type: number, ID: string, Extra: string, Responses: {ID: string, Addrs: string[]}[]}} event\n * @returns {import('ipfs-core-types/src/dht').QueryEvent}\n */\nexport const mapEvent = (event) => {\n  if (event.Type === SendingQuery) {\n    return {\n      name: 'SENDING_QUERY',\n      type: event.Type\n    }\n  }\n\n  if (event.Type === PeerResponse) {\n    return {\n      from: peerIdFromString(event.ID),\n      name: 'PEER_RESPONSE',\n      type: event.Type,\n      // TODO: how to infer this from the go-ipfs response\n      messageType: 0,\n      // TODO: how to infer this from the go-ipfs response\n      messageName: 'PUT_VALUE',\n      closer: (event.Responses || []).map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map(addr => multiaddr(addr)), protocols: [] })),\n      providers: (event.Responses || []).map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map(addr => multiaddr(addr)), protocols: [] }))\n      // TODO: how to infer this from the go-ipfs response\n      // record: ???\n    }\n  }\n\n  if (event.Type === FinalPeer) {\n    // dht.query ends with a FinalPeer event with no Responses\n    /** @type {import('@libp2p/interface-peer-info').PeerInfo} */\n    let peer = {\n      // @ts-expect-error go-ipfs does not return this\n      id: event.ID ?? peerIdFromString(event.ID),\n      /** @type {Multiaddr[]} */\n      multiaddrs: [],\n      protocols: []\n    }\n\n    if (event.Responses && event.Responses.length) {\n      // dht.findPeer has the result in the Responses field\n      peer = {\n        id: peerIdFromString(event.Responses[0].ID),\n        multiaddrs: event.Responses[0].Addrs.map(addr => multiaddr(addr)),\n        protocols: []\n      }\n    }\n\n    return {\n      name: 'FINAL_PEER',\n      type: event.Type,\n      peer\n    }\n  }\n\n  if (event.Type === QueryError) {\n    return {\n      name: 'QUERY_ERROR',\n      type: event.Type,\n      error: new Error(event.Extra)\n    }\n  }\n\n  if (event.Type === Provider) {\n    return {\n      name: 'PROVIDER',\n      type: event.Type,\n      providers: event.Responses.map(({ ID, Addrs }) => ({ id: peerIdFromString(ID), multiaddrs: Addrs.map(addr => multiaddr(addr)), protocols: [] }))\n    }\n  }\n\n  if (event.Type === Value) {\n    return {\n      name: 'VALUE',\n      type: event.Type,\n      value: uint8ArrayFromString(event.Extra, 'base64pad')\n    }\n  }\n\n  if (event.Type === AddingPeer) {\n    const peers = event.Responses.map(({ ID }) => peerIdFromString(ID))\n\n    if (!peers.length) {\n      throw new Error('No peer found')\n    }\n\n    return {\n      name: 'ADDING_PEER',\n      type: event.Type,\n      peer: peers[0]\n    }\n  }\n\n  if (event.Type === DialingPeer) {\n    return {\n      name: 'DIALING_PEER',\n      type: event.Type,\n      peer: peerIdFromString(event.ID)\n    }\n  }\n\n  throw new Error('Unknown DHT event type')\n}\n"]},"metadata":{},"sourceType":"module"}