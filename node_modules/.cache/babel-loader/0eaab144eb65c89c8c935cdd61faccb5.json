{"ast":null,"code":"/* eslint max-depth: [\"error\", 7] */\nimport { Token, Type } from 'cborg';\nimport * as cborgJson from 'cborg/json';\nimport { CID } from 'multiformats';\nimport { base64 } from 'multiformats/bases/base64';\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats').ToString<T>} ToString\n */\n\n/**\n * @typedef {import('cborg/interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal. Encoding a CID means replacing it with a `{\"/\":\"<CidString>}`\n * object as per the DAG-JSON spec.\n *\n * @param {any} obj\n * @returns {Token[]|null}\n */\n\nfunction cidEncoder(obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null; // any other kind of object\n  }\n\n  const cid = CID.asCID(obj);\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n\n  if (!cid) {\n    return null;\n  }\n\n  const cidString = cid.toString();\n  return [new Token(Type.map, Infinity, 1), new Token(Type.string, '/', 1), // key\n  new Token(Type.string, cidString, cidString.length), // value\n  new Token(Type.break, undefined, 1)];\n}\n/**\n * bytesEncoder will receive all Uint8Arrays (and friends) during encode, it\n * needs to replace it with a `{\"/\":{\"bytes\":\"Base64ByteString\"}}` object as\n * per the DAG-JSON spec.\n *\n * @param {Uint8Array} bytes\n * @returns {Token[]|null}\n */\n\n\nfunction bytesEncoder(bytes) {\n  const bytesString = base64.encode(bytes).slice(1); // no mbase prefix\n\n  return [new Token(Type.map, Infinity, 1), new Token(Type.string, '/', 1), // key\n  new Token(Type.map, Infinity, 1), // value\n  new Token(Type.string, 'bytes', 5), // inner key\n  new Token(Type.string, bytesString, bytesString.length), // inner value\n  new Token(Type.break, undefined, 1), new Token(Type.break, undefined, 1)];\n}\n/**\n * taBytesEncoder wraps bytesEncoder() but for the more exotic typed arrays so\n * that we access the underlying ArrayBuffer data\n *\n * @param {Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|Uint8ClampedArray|BigInt64Array|BigUint64Array} obj\n * @returns {Token[]|null}\n */\n\n\nfunction taBytesEncoder(obj) {\n  return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n}\n/**\n * abBytesEncoder wraps bytesEncoder() but for plain ArrayBuffers\n *\n * @param {ArrayBuffer} ab\n * @returns {Token[]|null}\n */\n\n\nfunction abBytesEncoder(ab) {\n  return bytesEncoder(new Uint8Array(ab));\n} // eslint-disable-next-line jsdoc/require-returns-check\n\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\n\n\nfunction undefinedEncoder() {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');\n}\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\n\n\nfunction numberEncoder(num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n\n  return null; // process with standard number encoder\n}\n\nconst encodeOptions = {\n  typeEncoders: {\n    Object: cidEncoder,\n    Buffer: bytesEncoder,\n    Uint8Array: bytesEncoder,\n    Int8Array: taBytesEncoder,\n    Uint16Array: taBytesEncoder,\n    Int16Array: taBytesEncoder,\n    Uint32Array: taBytesEncoder,\n    Int32Array: taBytesEncoder,\n    Float32Array: taBytesEncoder,\n    Float64Array: taBytesEncoder,\n    Uint8ClampedArray: taBytesEncoder,\n    BigInt64Array: taBytesEncoder,\n    BigUint64Array: taBytesEncoder,\n    DataView: taBytesEncoder,\n    ArrayBuffer: abBytesEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n};\n/**\n * @implements {DecodeTokenizer}\n */\n\nclass DagJsonTokenizer extends cborgJson.Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {object} [options]\n   */\n  constructor(data, options) {\n    super(data, options);\n    /** @type {Token[]} */\n\n    this.tokenBuffer = [];\n  }\n  /**\n   * @returns {boolean}\n   */\n\n\n  done() {\n    return this.tokenBuffer.length === 0 && super.done();\n  }\n  /**\n   * @returns {Token}\n   */\n\n\n  _next() {\n    if (this.tokenBuffer.length > 0) {\n      // @ts-ignore https://github.com/Microsoft/TypeScript/issues/30406\n      return this.tokenBuffer.pop();\n    }\n\n    return super.next();\n  }\n  /**\n   * Implements rules outlined in https://github.com/ipld/specs/pull/356\n   *\n   * @returns {Token}\n   */\n\n\n  next() {\n    const token = this._next();\n\n    if (token.type === Type.map) {\n      const keyToken = this._next();\n\n      if (keyToken.type === Type.string && keyToken.value === '/') {\n        const valueToken = this._next();\n\n        if (valueToken.type === Type.string) {\n          // *must* be a CID\n          const breakToken = this._next(); // swallow the end-of-map token\n\n\n          if (breakToken.type !== Type.break) {\n            throw new Error('Invalid encoded CID form');\n          }\n\n          this.tokenBuffer.push(valueToken); // CID.parse will pick this up after our tag token\n\n          return new Token(Type.tag, 42, 0);\n        }\n\n        if (valueToken.type === Type.map) {\n          const innerKeyToken = this._next();\n\n          if (innerKeyToken.type === Type.string && innerKeyToken.value === 'bytes') {\n            const innerValueToken = this._next();\n\n            if (innerValueToken.type === Type.string) {\n              // *must* be Bytes\n              for (let i = 0; i < 2; i++) {\n                const breakToken = this._next(); // swallow two end-of-map tokens\n\n\n                if (breakToken.type !== Type.break) {\n                  throw new Error('Invalid encoded Bytes form');\n                }\n              }\n\n              const bytes = base64.decode(`m${innerValueToken.value}`);\n              return new Token(Type.bytes, bytes, innerValueToken.value.length);\n            }\n\n            this.tokenBuffer.push(innerValueToken); // bail\n          }\n\n          this.tokenBuffer.push(innerKeyToken); // bail\n        }\n\n        this.tokenBuffer.push(valueToken); // bail\n      }\n\n      this.tokenBuffer.push(keyToken); // bail\n    }\n\n    return token;\n  }\n\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true,\n  // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}; // we're going to get TAG(42)STRING(\"bafy...\") from the tokenizer so we only need\n// to deal with the STRING(\"bafy...\") at this point\n\ndecodeOptions.tags[42] = CID.parse;\nexport const name = 'dag-json';\nexport const code = 0x0129;\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\n\nexport const encode = node => cborgJson.encode(node, encodeOptions);\n/**\n * @template T\n * @param {ByteView<T>} data\n * @returns {T}\n */\n\nexport const decode = data => {\n  // the tokenizer is stateful so we need a single instance of it\n  const options = Object.assign(decodeOptions, {\n    tokenizer: new DagJsonTokenizer(data, decodeOptions)\n  });\n  return cborgJson.decode(data, options);\n};\n/**\n * @template T\n * @param {T} node\n * @returns {ToString<T>}\n */\n\nexport const format = node => utf8Decoder.decode(encode(node));\nexport { format as stringify };\nconst utf8Decoder = new TextDecoder();\n/**\n * @template T\n * @param {ToString<T>} data\n * @returns {T}\n */\n\nexport const parse = data => decode(utf8Encoder.encode(data));\nconst utf8Encoder = new TextEncoder();","map":{"version":3,"sources":["/home/legasi/nft-marketplace/node_modules/@ipld/dag-json/src/index.js"],"names":["Token","Type","cborgJson","CID","base64","cidEncoder","obj","asCID","bytes","cid","cidString","toString","map","Infinity","string","length","break","undefined","bytesEncoder","bytesString","encode","slice","taBytesEncoder","Uint8Array","buffer","byteOffset","byteLength","abBytesEncoder","ab","undefinedEncoder","Error","numberEncoder","num","Number","isNaN","encodeOptions","typeEncoders","Object","Buffer","Int8Array","Uint16Array","Int16Array","Uint32Array","Int32Array","Float32Array","Float64Array","Uint8ClampedArray","BigInt64Array","BigUint64Array","DataView","ArrayBuffer","number","DagJsonTokenizer","Tokenizer","constructor","data","options","tokenBuffer","done","_next","pop","next","token","type","keyToken","value","valueToken","breakToken","push","tag","innerKeyToken","innerValueToken","i","decode","decodeOptions","allowIndefinite","allowUndefined","allowNaN","allowInfinity","allowBigInt","strict","useMaps","rejectDuplicateMapKeys","tags","parse","name","code","node","assign","tokenizer","format","utf8Decoder","stringify","TextDecoder","utf8Encoder","TextEncoder"],"mappings":"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","sourcesContent":["/* eslint max-depth: [\"error\", 7] */\nimport { Token, Type } from 'cborg'\nimport * as cborgJson from 'cborg/json'\nimport { CID } from 'multiformats'\nimport { base64 } from 'multiformats/bases/base64'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n/**\n * @template T\n * @typedef {import('multiformats').ToString<T>} ToString\n */\n/**\n * @typedef {import('cborg/interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal. Encoding a CID means replacing it with a `{\"/\":\"<CidString>}`\n * object as per the DAG-JSON spec.\n *\n * @param {any} obj\n * @returns {Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const cidString = cid.toString()\n\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.string, cidString, cidString.length), // value\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * bytesEncoder will receive all Uint8Arrays (and friends) during encode, it\n * needs to replace it with a `{\"/\":{\"bytes\":\"Base64ByteString\"}}` object as\n * per the DAG-JSON spec.\n *\n * @param {Uint8Array} bytes\n * @returns {Token[]|null}\n */\nfunction bytesEncoder (bytes) {\n  const bytesString = base64.encode(bytes).slice(1) // no mbase prefix\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.map, Infinity, 1), // value\n    new Token(Type.string, 'bytes', 5), // inner key\n    new Token(Type.string, bytesString, bytesString.length), // inner value\n    new Token(Type.break, undefined, 1),\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * taBytesEncoder wraps bytesEncoder() but for the more exotic typed arrays so\n * that we access the underlying ArrayBuffer data\n *\n * @param {Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|Uint8ClampedArray|BigInt64Array|BigUint64Array} obj\n * @returns {Token[]|null}\n */\nfunction taBytesEncoder (obj) {\n  return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n}\n\n/**\n * abBytesEncoder wraps bytesEncoder() but for plain ArrayBuffers\n *\n * @param {ArrayBuffer} ab\n * @returns {Token[]|null}\n */\nfunction abBytesEncoder (ab) {\n  return bytesEncoder(new Uint8Array(ab))\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null // process with standard number encoder\n}\n\nconst encodeOptions = {\n  typeEncoders: {\n    Object: cidEncoder,\n    Buffer: bytesEncoder,\n    Uint8Array: bytesEncoder,\n    Int8Array: taBytesEncoder,\n    Uint16Array: taBytesEncoder,\n    Int16Array: taBytesEncoder,\n    Uint32Array: taBytesEncoder,\n    Int32Array: taBytesEncoder,\n    Float32Array: taBytesEncoder,\n    Float64Array: taBytesEncoder,\n    Uint8ClampedArray: taBytesEncoder,\n    BigInt64Array: taBytesEncoder,\n    BigUint64Array: taBytesEncoder,\n    DataView: taBytesEncoder,\n    ArrayBuffer: abBytesEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass DagJsonTokenizer extends cborgJson.Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {object} [options]\n   */\n  constructor (data, options) {\n    super(data, options)\n    /** @type {Token[]} */\n    this.tokenBuffer = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  done () {\n    return this.tokenBuffer.length === 0 && super.done()\n  }\n\n  /**\n   * @returns {Token}\n   */\n  _next () {\n    if (this.tokenBuffer.length > 0) {\n      // @ts-ignore https://github.com/Microsoft/TypeScript/issues/30406\n      return this.tokenBuffer.pop()\n    }\n    return super.next()\n  }\n\n  /**\n   * Implements rules outlined in https://github.com/ipld/specs/pull/356\n   *\n   * @returns {Token}\n   */\n  next () {\n    const token = this._next()\n\n    if (token.type === Type.map) {\n      const keyToken = this._next()\n      if (keyToken.type === Type.string && keyToken.value === '/') {\n        const valueToken = this._next()\n        if (valueToken.type === Type.string) { // *must* be a CID\n          const breakToken = this._next() // swallow the end-of-map token\n          if (breakToken.type !== Type.break) {\n            throw new Error('Invalid encoded CID form')\n          }\n          this.tokenBuffer.push(valueToken) // CID.parse will pick this up after our tag token\n          return new Token(Type.tag, 42, 0)\n        }\n        if (valueToken.type === Type.map) {\n          const innerKeyToken = this._next()\n          if (innerKeyToken.type === Type.string && innerKeyToken.value === 'bytes') {\n            const innerValueToken = this._next()\n            if (innerValueToken.type === Type.string) { // *must* be Bytes\n              for (let i = 0; i < 2; i++) {\n                const breakToken = this._next() // swallow two end-of-map tokens\n                if (breakToken.type !== Type.break) {\n                  throw new Error('Invalid encoded Bytes form')\n                }\n              }\n              const bytes = base64.decode(`m${innerValueToken.value}`)\n              return new Token(Type.bytes, bytes, innerValueToken.value.length)\n            }\n            this.tokenBuffer.push(innerValueToken) // bail\n          }\n          this.tokenBuffer.push(innerKeyToken) // bail\n        }\n        this.tokenBuffer.push(valueToken) // bail\n      }\n      this.tokenBuffer.push(keyToken) // bail\n    }\n    return token\n  }\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n\n// we're going to get TAG(42)STRING(\"bafy...\") from the tokenizer so we only need\n// to deal with the STRING(\"bafy...\") at this point\ndecodeOptions.tags[42] = CID.parse\n\nexport const name = 'dag-json'\nexport const code = 0x0129\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborgJson.encode(node, encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => {\n  // the tokenizer is stateful so we need a single instance of it\n  const options = Object.assign(decodeOptions, { tokenizer: new DagJsonTokenizer(data, decodeOptions) })\n  return cborgJson.decode(data, options)\n}\n\n/**\n * @template T\n * @param {T} node\n * @returns {ToString<T>}\n */\nexport const format = (node) => utf8Decoder.decode(encode(node))\nexport { format as stringify }\nconst utf8Decoder = new TextDecoder()\n\n/**\n * @template T\n * @param {ToString<T>} data\n * @returns {T}\n */\nexport const parse = (data) => decode(utf8Encoder.encode(data))\nconst utf8Encoder = new TextEncoder()\n"]},"metadata":{},"sourceType":"module"}