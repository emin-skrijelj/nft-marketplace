{"ast":null,"code":"import { Token, Type } from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\n\nfunction toToken(_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix);\n}\n\nexport function decodeArrayCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeArray8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeArray16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeArray32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeArray64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);\n  }\n\n  return toToken(data, pos, 9, l);\n}\nexport function decodeArrayIndefinite(data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);\n  }\n\n  return toToken(data, pos, 1, Infinity);\n}\nexport function encodeArray(buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value);\n}\nencodeArray.compareTokens = uint.encodeUint.compareTokens;\n\nencodeArray.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};","map":{"version":3,"sources":["/home/legasi/nft-marketplace/node_modules/cborg/esm/lib/4array.js"],"names":["Token","Type","uint","decodeErrPrefix","toToken","_data","_pos","prefix","length","array","decodeArrayCompact","data","pos","minor","_options","decodeArray8","_minor","options","readUint8","decodeArray16","readUint16","decodeArray32","readUint32","decodeArray64","l","readUint64","Error","decodeArrayIndefinite","allowIndefinite","Infinity","encodeArray","buf","token","encodeUintValue","majorEncoded","value","compareTokens","encodeUint","encodedSize"],"mappings":"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","sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nfunction toToken(_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix);\n}\nexport function decodeArrayCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeArray8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeArray16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeArray32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeArray64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer array lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nexport function decodeArrayIndefinite(data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return toToken(data, pos, 1, Infinity);\n}\nexport function encodeArray(buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value);\n}\nencodeArray.compareTokens = uint.encodeUint.compareTokens;\nencodeArray.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};"]},"metadata":{},"sourceType":"module"}