{"ast":null,"code":"/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\nimport * as ip from './ip.js';\nimport { getProtocol } from './protocols-table.js';\nimport { CID } from 'multiformats/cid';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport * as Digest from 'multiformats/hashes/digest';\nimport varint from 'varint';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nexport function convert(proto, a) {\n  if (a instanceof Uint8Array) {\n    return convertToString(proto, a);\n  } else {\n    return convertToBytes(proto, a);\n  }\n}\n/**\n * Convert [code,Uint8Array] to string\n */\n\nexport function convertToString(proto, buf) {\n  const protocol = getProtocol(proto);\n\n  switch (protocol.code) {\n    case 4: // ipv4\n\n    case 41:\n      // ipv6\n      return bytes2ip(buf);\n\n    case 42:\n      // ipv6zone\n      return bytes2str(buf);\n\n    case 6: // tcp\n\n    case 273: // udp\n\n    case 33: // dccp\n\n    case 132:\n      // sctp\n      return bytes2port(buf).toString();\n\n    case 53: // dns\n\n    case 54: // dns4\n\n    case 55: // dns6\n\n    case 56: // dnsaddr\n\n    case 400: // unix\n\n    case 449: // sni\n\n    case 777:\n      // memory\n      return bytes2str(buf);\n\n    case 421:\n      // ipfs\n      return bytes2mh(buf);\n\n    case 444:\n      // onion\n      return bytes2onion(buf);\n\n    case 445:\n      // onion3\n      return bytes2onion(buf);\n\n    case 466:\n      // certhash\n      return bytes2mb(buf);\n\n    default:\n      return uint8ArrayToString(buf, 'base16');\n    // no clue. convert to hex\n  }\n}\nexport function convertToBytes(proto, str) {\n  const protocol = getProtocol(proto);\n\n  switch (protocol.code) {\n    case 4:\n      // ipv4\n      return ip2bytes(str);\n\n    case 41:\n      // ipv6\n      return ip2bytes(str);\n\n    case 42:\n      // ipv6zone\n      return str2bytes(str);\n\n    case 6: // tcp\n\n    case 273: // udp\n\n    case 33: // dccp\n\n    case 132:\n      // sctp\n      return port2bytes(parseInt(str, 10));\n\n    case 53: // dns\n\n    case 54: // dns4\n\n    case 55: // dns6\n\n    case 56: // dnsaddr\n\n    case 400: // unix\n\n    case 449: // sni\n\n    case 777:\n      // memory\n      return str2bytes(str);\n\n    case 421:\n      // ipfs\n      return mh2bytes(str);\n\n    case 444:\n      // onion\n      return onion2bytes(str);\n\n    case 445:\n      // onion3\n      return onion32bytes(str);\n\n    case 466:\n      // certhash\n      return mb2bytes(str);\n\n    default:\n      return uint8ArrayFromString(str, 'base16');\n    // no clue. convert from hex\n  }\n}\nconst decoders = Object.values(bases).map(c => c.decoder);\n\nconst anybaseDecoder = function () {\n  let acc = decoders[0].or(decoders[1]);\n  decoders.slice(2).forEach(d => acc = acc.or(d));\n  return acc;\n}();\n\nfunction ip2bytes(ipString) {\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address');\n  }\n\n  return ip.toBytes(ipString);\n}\n\nfunction bytes2ip(ipBuff) {\n  const ipString = ip.toString(ipBuff, 0, ipBuff.length);\n\n  if (ipString == null) {\n    throw new Error('ipBuff is required');\n  }\n\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address');\n  }\n\n  return ipString;\n}\n\nfunction port2bytes(port) {\n  const buf = new ArrayBuffer(2);\n  const view = new DataView(buf);\n  view.setUint16(0, port);\n  return new Uint8Array(buf);\n}\n\nfunction bytes2port(buf) {\n  const view = new DataView(buf.buffer);\n  return view.getUint16(buf.byteOffset);\n}\n\nfunction str2bytes(str) {\n  const buf = uint8ArrayFromString(str);\n  const size = Uint8Array.from(varint.encode(buf.length));\n  return uint8ArrayConcat([size, buf], size.length + buf.length);\n}\n\nfunction bytes2str(buf) {\n  const size = varint.decode(buf);\n  buf = buf.slice(varint.decode.bytes);\n\n  if (buf.length !== size) {\n    throw new Error('inconsistent lengths');\n  }\n\n  return uint8ArrayToString(buf);\n}\n\nfunction mh2bytes(hash) {\n  let mh;\n\n  if (hash[0] === 'Q' || hash[0] === '1') {\n    mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes;\n  } else {\n    mh = CID.parse(hash).multihash.bytes;\n  } // the address is a varint prefixed multihash string representation\n\n\n  const size = Uint8Array.from(varint.encode(mh.length));\n  return uint8ArrayConcat([size, mh], size.length + mh.length);\n}\n\nfunction mb2bytes(mbstr) {\n  const mb = anybaseDecoder.decode(mbstr);\n  const size = Uint8Array.from(varint.encode(mb.length));\n  return uint8ArrayConcat([size, mb], size.length + mb.length);\n}\n\nfunction bytes2mb(buf) {\n  const size = varint.decode(buf);\n  const hash = buf.slice(varint.decode.bytes);\n\n  if (hash.length !== size) {\n    throw new Error('inconsistent lengths');\n  }\n\n  return 'u' + uint8ArrayToString(hash, 'base64url');\n}\n/**\n * Converts bytes to bas58btc string\n */\n\n\nfunction bytes2mh(buf) {\n  const size = varint.decode(buf);\n  const address = buf.slice(varint.decode.bytes);\n\n  if (address.length !== size) {\n    throw new Error('inconsistent lengths');\n  }\n\n  return uint8ArrayToString(address, 'base58btc');\n}\n\nfunction onion2bytes(str) {\n  const addr = str.split(':');\n\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n  }\n\n  if (addr[0].length !== 16) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);\n  } // onion addresses do not include the multibase prefix, add it before decoding\n\n\n  const buf = base32.decode('b' + addr[0]); // onion port number\n\n  const port = parseInt(addr[1], 10);\n\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)');\n  }\n\n  const portBuf = port2bytes(port);\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\n\nfunction onion32bytes(str) {\n  const addr = str.split(':');\n\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n  }\n\n  if (addr[0].length !== 56) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);\n  } // onion addresses do not include the multibase prefix, add it before decoding\n\n\n  const buf = base32.decode(`b${addr[0]}`); // onion port number\n\n  const port = parseInt(addr[1], 10);\n\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)');\n  }\n\n  const portBuf = port2bytes(port);\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\n\nfunction bytes2onion(buf) {\n  const addrBytes = buf.slice(0, buf.length - 2);\n  const portBytes = buf.slice(buf.length - 2);\n  const addr = uint8ArrayToString(addrBytes, 'base32');\n  const port = bytes2port(portBytes);\n  return `${addr}:${port}`;\n}","map":{"version":3,"mappings":"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","names":["ip","getProtocol","CID","base32","base58btc","bases","Digest","varint","toString","uint8ArrayToString","fromString","uint8ArrayFromString","concat","uint8ArrayConcat","convert","proto","a","Uint8Array","convertToString","convertToBytes","buf","protocol","code","bytes2ip","bytes2str","bytes2port","bytes2mh","bytes2onion","bytes2mb","str","ip2bytes","str2bytes","port2bytes","parseInt","mh2bytes","onion2bytes","onion32bytes","mb2bytes","decoders","Object","values","map","c","decoder","anybaseDecoder","acc","or","slice","forEach","d","ipString","isIP","Error","toBytes","ipBuff","length","port","ArrayBuffer","view","DataView","setUint16","buffer","getUint16","byteOffset","size","from","encode","decode","bytes","hash","mh","parse","multihash","mbstr","mb","address","addr","split","join","portBuf","addrBytes","portBytes"],"sources":["/home/legasi/nft-marketplace/node_modules/ipfs-core-utils/node_modules/@multiformats/multiaddr/src/convert.ts"],"sourcesContent":["/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\n\nimport * as ip from './ip.js'\nimport { getProtocol } from './protocols-table.js'\nimport { CID } from 'multiformats/cid'\nimport { base32 } from 'multiformats/bases/base32'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { bases } from 'multiformats/basics'\nimport * as Digest from 'multiformats/hashes/digest'\nimport varint from 'varint'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\n\n/**\n * converts (serializes) addresses\n */\nexport function convert (proto: string, a: string): Uint8Array\nexport function convert (proto: string, a: Uint8Array): string\nexport function convert (proto: string, a: string | Uint8Array): Uint8Array | string {\n  if (a instanceof Uint8Array) {\n    return convertToString(proto, a)\n  } else {\n    return convertToBytes(proto, a)\n  }\n}\n\n/**\n * Convert [code,Uint8Array] to string\n */\nexport function convertToString (proto: number | string, buf: Uint8Array): string {\n  const protocol = getProtocol(proto)\n  switch (protocol.code) {\n    case 4: // ipv4\n    case 41: // ipv6\n      return bytes2ip(buf)\n    case 42: // ipv6zone\n      return bytes2str(buf)\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return bytes2port(buf).toString()\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 449: // sni\n    case 777: // memory\n      return bytes2str(buf)\n\n    case 421: // ipfs\n      return bytes2mh(buf)\n    case 444: // onion\n      return bytes2onion(buf)\n    case 445: // onion3\n      return bytes2onion(buf)\n    case 466: // certhash\n      return bytes2mb(buf)\n    default:\n      return uint8ArrayToString(buf, 'base16') // no clue. convert to hex\n  }\n}\n\nexport function convertToBytes (proto: string | number, str: string): Uint8Array {\n  const protocol = getProtocol(proto)\n  switch (protocol.code) {\n    case 4: // ipv4\n      return ip2bytes(str)\n    case 41: // ipv6\n      return ip2bytes(str)\n    case 42: // ipv6zone\n      return str2bytes(str)\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return port2bytes(parseInt(str, 10))\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 449: // sni\n    case 777: // memory\n      return str2bytes(str)\n\n    case 421: // ipfs\n      return mh2bytes(str)\n    case 444: // onion\n      return onion2bytes(str)\n    case 445: // onion3\n      return onion32bytes(str)\n    case 466: // certhash\n      return mb2bytes(str)\n    default:\n      return uint8ArrayFromString(str, 'base16') // no clue. convert from hex\n  }\n}\n\nconst decoders = Object.values(bases).map((c) => c.decoder)\nconst anybaseDecoder = (function () {\n  let acc = decoders[0].or(decoders[1])\n  decoders.slice(2).forEach((d) => (acc = acc.or(d)))\n  return acc\n})()\n\nfunction ip2bytes (ipString: string): Uint8Array {\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ip.toBytes(ipString)\n}\n\nfunction bytes2ip (ipBuff: Uint8Array): string {\n  const ipString = ip.toString(ipBuff, 0, ipBuff.length)\n  if (ipString == null) {\n    throw new Error('ipBuff is required')\n  }\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ipString\n}\n\nfunction port2bytes (port: number): Uint8Array {\n  const buf = new ArrayBuffer(2)\n  const view = new DataView(buf)\n  view.setUint16(0, port)\n\n  return new Uint8Array(buf)\n}\n\nfunction bytes2port (buf: Uint8Array): number {\n  const view = new DataView(buf.buffer)\n  return view.getUint16(buf.byteOffset)\n}\n\nfunction str2bytes (str: string): Uint8Array {\n  const buf = uint8ArrayFromString(str)\n  const size = Uint8Array.from(varint.encode(buf.length))\n  return uint8ArrayConcat([size, buf], size.length + buf.length)\n}\n\nfunction bytes2str (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  buf = buf.slice(varint.decode.bytes)\n\n  if (buf.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return uint8ArrayToString(buf)\n}\n\nfunction mh2bytes (hash: string): Uint8Array {\n  let mh\n\n  if (hash[0] === 'Q' || hash[0] === '1') {\n    mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes\n  } else {\n    mh = CID.parse(hash).multihash.bytes\n  }\n\n  // the address is a varint prefixed multihash string representation\n  const size = Uint8Array.from(varint.encode(mh.length))\n  return uint8ArrayConcat([size, mh], size.length + mh.length)\n}\n\nfunction mb2bytes (mbstr: string): Uint8Array {\n  const mb = anybaseDecoder.decode(mbstr)\n  const size = Uint8Array.from(varint.encode(mb.length))\n  return uint8ArrayConcat([size, mb], size.length + mb.length)\n}\nfunction bytes2mb (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  const hash = buf.slice(varint.decode.bytes)\n\n  if (hash.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return 'u' + uint8ArrayToString(hash, 'base64url')\n}\n\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  const address = buf.slice(varint.decode.bytes)\n\n  if (address.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return uint8ArrayToString(address, 'base58btc')\n}\n\nfunction onion2bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n  if (addr[0].length !== 16) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`)\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode('b' + addr[0])\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2bytes(port)\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nfunction onion32bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n  if (addr[0].length !== 56) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`)\n  }\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode(`b${addr[0]}`)\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2bytes(port)\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nfunction bytes2onion (buf: Uint8Array): string {\n  const addrBytes = buf.slice(0, buf.length - 2)\n  const portBytes = buf.slice(buf.length - 2)\n  const addr = uint8ArrayToString(addrBytes, 'base32')\n  const port = bytes2port(portBytes)\n  return `${addr}:${port}`\n}\n"]},"metadata":{},"sourceType":"module"}