{"ast":null,"code":"import { parseIP } from \"@chainsafe/is-ip/parse\";\nimport { cidrMask, parseCidr } from \"./cidr.js\";\nimport { containsIp, maskIp } from \"./ip.js\";\nimport { ipToString, maskToHex, simpleMaskLength } from \"./util.js\";\nexport class IpNet {\n  /**\n   *\n   * @param ipOrCidr either network ip or full cidr address\n   * @param mask in case ipOrCidr is network this can be either mask in decimal format or as ip address\n   */\n  constructor(ipOrCidr, mask) {\n    if (mask == null) {\n      ({\n        network: this.network,\n        mask: this.mask\n      } = parseCidr(ipOrCidr));\n    } else {\n      const ipResult = parseIP(ipOrCidr);\n\n      if (ipResult == null) {\n        throw new Error(\"Failed to parse network\");\n      }\n\n      mask = String(mask);\n      const m = parseInt(mask, 10);\n\n      if (Number.isNaN(m) || String(m).length !== mask.length || m < 0 || m > ipResult.length * 8) {\n        const maskResult = parseIP(mask);\n\n        if (maskResult == null) {\n          throw new Error(\"Failed to parse mask\");\n        }\n\n        this.mask = maskResult;\n      } else {\n        this.mask = cidrMask(m, 8 * ipResult.length);\n      }\n\n      this.network = maskIp(ipResult, this.mask);\n    }\n  }\n  /**\n   * Checks if netmask contains ip address\n   * @param ip\n   * @returns\n   */\n\n\n  contains(ip) {\n    return containsIp({\n      network: this.network,\n      mask: this.mask\n    }, ip);\n  }\n  /**Serializes back to string format */\n\n\n  toString() {\n    const l = simpleMaskLength(this.mask);\n    const mask = l !== -1 ? String(l) : maskToHex(this.mask);\n    return ipToString(this.network) + \"/\" + mask;\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,OAAT,QAAwB,wBAAxB;AACA,SAASC,QAAT,EAAmBC,SAAnB,QAAoC,WAApC;AACA,SAASC,UAAT,EAAqBC,MAArB,QAAmC,SAAnC;AACA,SAASC,UAAT,EAAqBC,SAArB,EAAgCC,gBAAhC,QAAwD,WAAxD;AAEA,OAAM,MAAOC,KAAP,CAAY;AAIhB;;;;;AAKAC,cAAYC,QAAZ,EAA8BC,IAA9B,EAAoD;AAClD,QAAIA,IAAI,IAAI,IAAZ,EAAkB;AAChB,OAAC;AAAEC,eAAO,EAAE,KAAKA,OAAhB;AAAyBD,YAAI,EAAE,KAAKA;AAApC,UAA6CT,SAAS,CAACQ,QAAD,CAAvD;AACD,KAFD,MAEO;AACL,YAAMG,QAAQ,GAAGb,OAAO,CAACU,QAAD,CAAxB;;AACA,UAAIG,QAAQ,IAAI,IAAhB,EAAsB;AACpB,cAAM,IAAIC,KAAJ,CAAU,yBAAV,CAAN;AACD;;AACDH,UAAI,GAAGI,MAAM,CAACJ,IAAD,CAAb;AACA,YAAMK,CAAC,GAAGC,QAAQ,CAACN,IAAD,EAAO,EAAP,CAAlB;;AACA,UACEO,MAAM,CAACC,KAAP,CAAaH,CAAb,KACAD,MAAM,CAACC,CAAD,CAAN,CAAUI,MAAV,KAAqBT,IAAI,CAACS,MAD1B,IAEAJ,CAAC,GAAG,CAFJ,IAGAA,CAAC,GAAGH,QAAQ,CAACO,MAAT,GAAkB,CAJxB,EAKE;AACA,cAAMC,UAAU,GAAGrB,OAAO,CAACW,IAAD,CAA1B;;AACA,YAAIU,UAAU,IAAI,IAAlB,EAAwB;AACtB,gBAAM,IAAIP,KAAJ,CAAU,sBAAV,CAAN;AACD;;AACD,aAAKH,IAAL,GAAYU,UAAZ;AACD,OAXD,MAWO;AACL,aAAKV,IAAL,GAAYV,QAAQ,CAACe,CAAD,EAAI,IAAIH,QAAQ,CAACO,MAAjB,CAApB;AACD;;AACD,WAAKR,OAAL,GAAeR,MAAM,CAACS,QAAD,EAAW,KAAKF,IAAhB,CAArB;AACD;AACF;AAED;;;;;;;AAKAW,UAAQ,CAACC,EAAD,EAAmC;AACzC,WAAOpB,UAAU,CAAC;AAAES,aAAO,EAAE,KAAKA,OAAhB;AAAyBD,UAAI,EAAE,KAAKA;AAApC,KAAD,EAA6CY,EAA7C,CAAjB;AACD;AAED;;;AACAC,UAAQ;AACN,UAAMC,CAAC,GAAGlB,gBAAgB,CAAC,KAAKI,IAAN,CAA1B;AACA,UAAMA,IAAI,GAAGc,CAAC,KAAK,CAAC,CAAP,GAAWV,MAAM,CAACU,CAAD,CAAjB,GAAuBnB,SAAS,CAAC,KAAKK,IAAN,CAA7C;AACA,WAAON,UAAU,CAAC,KAAKO,OAAN,CAAV,GAA2B,GAA3B,GAAiCD,IAAxC;AACD;;AAnDe","names":["parseIP","cidrMask","parseCidr","containsIp","maskIp","ipToString","maskToHex","simpleMaskLength","IpNet","constructor","ipOrCidr","mask","network","ipResult","Error","String","m","parseInt","Number","isNaN","length","maskResult","contains","ip","toString","l"],"sources":["/home/legasi/nft-marketplace/node_modules/@chainsafe/netmask/src/ipnet.ts"],"sourcesContent":["import { parseIP } from \"@chainsafe/is-ip/parse\";\nimport { cidrMask, parseCidr } from \"./cidr.js\";\nimport { containsIp, maskIp } from \"./ip.js\";\nimport { ipToString, maskToHex, simpleMaskLength } from \"./util.js\";\n\nexport class IpNet {\n  public readonly network: Uint8Array;\n  public readonly mask: Uint8Array;\n\n  /**\n   *\n   * @param ipOrCidr either network ip or full cidr address\n   * @param mask in case ipOrCidr is network this can be either mask in decimal format or as ip address\n   */\n  constructor(ipOrCidr: string, mask?: string | number) {\n    if (mask == null) {\n      ({ network: this.network, mask: this.mask } = parseCidr(ipOrCidr));\n    } else {\n      const ipResult = parseIP(ipOrCidr);\n      if (ipResult == null) {\n        throw new Error(\"Failed to parse network\");\n      }\n      mask = String(mask);\n      const m = parseInt(mask, 10);\n      if (\n        Number.isNaN(m) ||\n        String(m).length !== mask.length ||\n        m < 0 ||\n        m > ipResult.length * 8\n      ) {\n        const maskResult = parseIP(mask);\n        if (maskResult == null) {\n          throw new Error(\"Failed to parse mask\");\n        }\n        this.mask = maskResult;\n      } else {\n        this.mask = cidrMask(m, 8 * ipResult.length);\n      }\n      this.network = maskIp(ipResult, this.mask);\n    }\n  }\n\n  /**\n   * Checks if netmask contains ip address\n   * @param ip\n   * @returns\n   */\n  contains(ip: Uint8Array | number[] | string): boolean {\n    return containsIp({ network: this.network, mask: this.mask }, ip);\n  }\n\n  /**Serializes back to string format */\n  toString(): string {\n    const l = simpleMaskLength(this.mask);\n    const mask = l !== -1 ? String(l) : maskToHex(this.mask);\n    return ipToString(this.network) + \"/\" + mask;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}