{"ast":null,"code":"const empty = new Uint8Array(0);\n/**\n * @param {Uint8Array} d\n */\n\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\n/**\n * @param {string} hex\n */\n\n\nconst fromHex = hex => {\n  const hexes = hex.match(/../g);\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n};\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\n\n\nconst equals = (aa, bb) => {\n  if (aa === bb) return true;\n\n  if (aa.byteLength !== bb.byteLength) {\n    return false;\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\n\n\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o;\n  if (o instanceof ArrayBuffer) return new Uint8Array(o);\n\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n  }\n\n  throw new Error('Unknown type, must be binary type');\n};\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\n\n\nconst isBinary = o => o instanceof ArrayBuffer || ArrayBuffer.isView(o);\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\n\n\nconst fromString = str => new TextEncoder().encode(str);\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\n\n\nconst toString = b => new TextDecoder().decode(b);\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty };","map":{"version":3,"sources":["/home/legasi/nft-marketplace/node_modules/multiformats/src/bytes.js"],"names":["empty","Uint8Array","toHex","d","reduce","hex","byte","toString","padStart","fromHex","hexes","match","map","b","parseInt","equals","aa","bb","byteLength","ii","coerce","o","constructor","name","ArrayBuffer","isView","buffer","byteOffset","Error","isBinary","fromString","str","TextEncoder","encode","TextDecoder","decode"],"mappings":"AAAA,MAAMA,KAAK,GAAG,IAAIC,UAAJ,CAAe,CAAf,CAAd;AAEA;AACA;AACA;;AACA,MAAMC,KAAK,GAAGC,CAAC,IAAIA,CAAC,CAACC,MAAF,CAAS,CAACC,GAAD,EAAMC,IAAN,KAAeD,GAAG,GAAGC,IAAI,CAACC,QAAL,CAAc,EAAd,EAAkBC,QAAlB,CAA2B,CAA3B,EAA8B,GAA9B,CAA9B,EAAkE,EAAlE,CAAnB;AAEA;AACA;AACA;;;AACA,MAAMC,OAAO,GAAGJ,GAAG,IAAI;AACrB,QAAMK,KAAK,GAAGL,GAAG,CAACM,KAAJ,CAAU,KAAV,CAAd;AACA,SAAOD,KAAK,GAAG,IAAIT,UAAJ,CAAeS,KAAK,CAACE,GAAN,CAAUC,CAAC,IAAIC,QAAQ,CAACD,CAAD,EAAI,EAAJ,CAAvB,CAAf,CAAH,GAAqDb,KAAjE;AACD,CAHD;AAKA;AACA;AACA;AACA;;;AACA,MAAMe,MAAM,GAAG,CAACC,EAAD,EAAKC,EAAL,KAAY;AACzB,MAAID,EAAE,KAAKC,EAAX,EAAe,OAAO,IAAP;;AACf,MAAID,EAAE,CAACE,UAAH,KAAkBD,EAAE,CAACC,UAAzB,EAAqC;AACnC,WAAO,KAAP;AACD;;AAED,OAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGH,EAAE,CAACE,UAAzB,EAAqCC,EAAE,EAAvC,EAA2C;AACzC,QAAIH,EAAE,CAACG,EAAD,CAAF,KAAWF,EAAE,CAACE,EAAD,CAAjB,EAAuB;AACrB,aAAO,KAAP;AACD;AACF;;AAED,SAAO,IAAP;AACD,CAbD;AAeA;AACA;AACA;AACA;;;AACA,MAAMC,MAAM,GAAGC,CAAC,IAAI;AAClB,MAAIA,CAAC,YAAYpB,UAAb,IAA2BoB,CAAC,CAACC,WAAF,CAAcC,IAAd,KAAuB,YAAtD,EAAoE,OAAOF,CAAP;AACpE,MAAIA,CAAC,YAAYG,WAAjB,EAA8B,OAAO,IAAIvB,UAAJ,CAAeoB,CAAf,CAAP;;AAC9B,MAAIG,WAAW,CAACC,MAAZ,CAAmBJ,CAAnB,CAAJ,EAA2B;AACzB,WAAO,IAAIpB,UAAJ,CAAeoB,CAAC,CAACK,MAAjB,EAAyBL,CAAC,CAACM,UAA3B,EAAuCN,CAAC,CAACH,UAAzC,CAAP;AACD;;AACD,QAAM,IAAIU,KAAJ,CAAU,mCAAV,CAAN;AACD,CAPD;AASA;AACA;AACA;AACA;;;AACA,MAAMC,QAAQ,GAAGR,CAAC,IAChBA,CAAC,YAAYG,WAAb,IAA4BA,WAAW,CAACC,MAAZ,CAAmBJ,CAAnB,CAD9B;AAGA;AACA;AACA;AACA;;;AACA,MAAMS,UAAU,GAAGC,GAAG,IAAK,IAAIC,WAAJ,EAAD,CAAoBC,MAApB,CAA2BF,GAA3B,CAA1B;AAEA;AACA;AACA;AACA;;;AACA,MAAMxB,QAAQ,GAAGM,CAAC,IAAK,IAAIqB,WAAJ,EAAD,CAAoBC,MAApB,CAA2BtB,CAA3B,CAAtB;;AAEA,SAASE,MAAT,EAAiBK,MAAjB,EAAyBS,QAAzB,EAAmCpB,OAAnC,EAA4CP,KAA5C,EAAmD4B,UAAnD,EAA+DvB,QAA/D,EAAyEP,KAAzE","sourcesContent":["const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n"]},"metadata":{},"sourceType":"module"}