{"ast":null,"code":"/* eslint-disable no-undef */\n'use strict';\n\nconst {\n  fetch,\n  Request,\n  Headers\n} = require('./http/fetch');\n\nconst {\n  TimeoutError,\n  HTTPError\n} = require('./http/error');\n\nconst merge = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst {\n  URL,\n  URLSearchParams\n} = require('iso-url');\n\nconst anySignal = require('any-signal');\n\nconst browserReableStreamToIt = require('browser-readablestream-to-it');\n\nconst {\n  isBrowser,\n  isWebWorker\n} = require('./env');\n\nconst all = require('it-all');\n/**\n * @typedef {import('stream').Readable} NodeReadableStream\n * @typedef {import('./types').HTTPOptions} HTTPOptions\n * @typedef {import('./types').ExtendedResponse} ExtendedResponse\n */\n\n/**\n * @template TResponse\n * @param {Promise<TResponse>} promise\n * @param {number | undefined} ms\n * @param {AbortController} abortController\n * @returns {Promise<TResponse>}\n */\n\n\nconst timeout = (promise, ms, abortController) => {\n  if (ms === undefined) {\n    return promise;\n  }\n\n  const start = Date.now();\n\n  const timedOut = () => {\n    const time = Date.now() - start;\n    return time >= ms;\n  };\n\n  return new Promise((resolve, reject) => {\n    const timeoutID = setTimeout(() => {\n      if (timedOut()) {\n        reject(new TimeoutError());\n        abortController.abort();\n      }\n    }, ms);\n    /**\n     * @param {(value: any) => void } next\n     */\n\n    const after = next => {\n      /**\n       * @param {any} res\n       */\n      const fn = res => {\n        clearTimeout(timeoutID);\n\n        if (timedOut()) {\n          reject(new TimeoutError());\n          return;\n        }\n\n        next(res);\n      };\n\n      return fn;\n    };\n\n    promise.then(after(resolve), after(reject));\n  });\n};\n\nconst defaults = {\n  throwHttpErrors: true,\n  credentials: 'same-origin'\n};\n\nclass HTTP {\n  /**\n   *\n   * @param {HTTPOptions} options\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    /** @type {HTTPOptions} */\n    this.opts = merge(defaults, options);\n  }\n  /**\n   * Fetch\n   *\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<ExtendedResponse>}\n   */\n\n\n  async fetch(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /** @type {HTTPOptions} */\n    const opts = merge(this.opts, options); // @ts-expect-error\n\n    const headers = new Headers(opts.headers); // validate resource type\n    // @ts-expect-error\n\n    if (typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request)) {\n      throw new TypeError('`resource` must be a string, URL, or Request');\n    }\n\n    const url = new URL(resource.toString(), opts.base);\n    const {\n      searchParams,\n      transformSearchParams,\n      json\n    } = opts;\n\n    if (searchParams) {\n      if (typeof transformSearchParams === 'function') {\n        // @ts-ignore\n        url.search = transformSearchParams(new URLSearchParams(opts.searchParams));\n      } else {\n        // @ts-ignore\n        url.search = new URLSearchParams(opts.searchParams);\n      }\n    }\n\n    if (json) {\n      opts.body = JSON.stringify(opts.json);\n      headers.set('content-type', 'application/json');\n    }\n\n    const abortController = new AbortController(); // @ts-ignore\n\n    const signal = anySignal([abortController.signal, opts.signal]);\n\n    if (globalThis.ReadableStream != null && opts.body instanceof globalThis.ReadableStream && (isBrowser || isWebWorker)) {\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1387483\n      opts.body = new Blob(await all(browserReableStreamToIt(opts.body)));\n    }\n    /** @type {ExtendedResponse} */\n    // @ts-expect-error additional fields are assigned below\n\n\n    const response = await timeout(fetch(url.toString(), { ...opts,\n      signal,\n      // @ts-expect-error non-browser fetch implementations may take extra options\n      timeout: undefined,\n      headers,\n      // https://fetch.spec.whatwg.org/#dom-requestinit-duplex\n      // https://github.com/whatwg/fetch/issues/1254\n      duplex: 'half'\n    }), opts.timeout, abortController);\n\n    if (!response.ok && opts.throwHttpErrors) {\n      if (opts.handleError) {\n        await opts.handleError(response);\n      }\n\n      throw new HTTPError(response);\n    }\n\n    response.iterator = async function* () {\n      yield* fromStream(response.body);\n    };\n\n    response.ndjson = async function* () {\n      for await (const chunk of ndjson(response.iterator())) {\n        if (options.transform) {\n          yield options.transform(chunk);\n        } else {\n          yield chunk;\n        }\n      }\n    };\n\n    return response;\n  }\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n\n\n  post(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, { ...options,\n      method: 'POST'\n    });\n  }\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n\n\n  get(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, { ...options,\n      method: 'GET'\n    });\n  }\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n\n\n  put(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, { ...options,\n      method: 'PUT'\n    });\n  }\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n\n\n  delete(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, { ...options,\n      method: 'DELETE'\n    });\n  }\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n\n\n  options(resource) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.fetch(resource, { ...options,\n      method: 'OPTIONS'\n    });\n  }\n\n}\n/**\n * Parses NDJSON chunks from an iterator\n *\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {AsyncIterable<any>}\n */\n\n\nconst ndjson = async function* (source) {\n  const decoder = new TextDecoder();\n  let buf = '';\n\n  for await (const chunk of source) {\n    buf += decoder.decode(chunk, {\n      stream: true\n    });\n    const lines = buf.split(/\\r?\\n/);\n\n    for (let i = 0; i < lines.length - 1; i++) {\n      const l = lines[i].trim();\n\n      if (l.length > 0) {\n        yield JSON.parse(l);\n      }\n    }\n\n    buf = lines[lines.length - 1];\n  }\n\n  buf += decoder.decode();\n  buf = buf.trim();\n\n  if (buf.length !== 0) {\n    yield JSON.parse(buf);\n  }\n};\n/**\n * Stream to AsyncIterable\n *\n * @template TChunk\n * @param {ReadableStream<TChunk> | NodeReadableStream | null} source\n * @returns {AsyncIterable<TChunk>}\n */\n\n\nconst fromStream = source => {\n  if (isAsyncIterable(source)) {\n    return source;\n  } // Workaround for https://github.com/node-fetch/node-fetch/issues/766\n\n\n  if (isNodeReadableStream(source)) {\n    const iter = source[Symbol.asyncIterator]();\n    return {\n      [Symbol.asyncIterator]() {\n        return {\n          next: iter.next.bind(iter),\n\n          return(value) {\n            source.destroy();\n\n            if (typeof iter.return === 'function') {\n              return iter.return();\n            }\n\n            return Promise.resolve({\n              done: true,\n              value\n            });\n          }\n\n        };\n      }\n\n    };\n  }\n\n  if (isWebReadableStream(source)) {\n    const reader = source.getReader();\n    return async function* () {\n      try {\n        while (true) {\n          // Read from the stream\n          const {\n            done,\n            value\n          } = await reader.read(); // Exit if we're done\n\n          if (done) return; // Else yield the chunk\n\n          if (value) {\n            yield value;\n          }\n        }\n      } finally {\n        reader.releaseLock();\n      }\n    }();\n  }\n\n  throw new TypeError('Body can\\'t be converted to AsyncIterable');\n};\n/**\n * Check if it's an AsyncIterable\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|AsyncIterable<TChunk>} value\n * @returns {value is AsyncIterable<TChunk>}\n */\n\n\nconst isAsyncIterable = value => {\n  return typeof value === 'object' && value !== null && typeof\n  /** @type {any} */\n  value[Symbol.asyncIterator] === 'function';\n};\n/**\n * Check for web readable stream\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|ReadableStream<TChunk>} value\n * @returns {value is ReadableStream<TChunk>}\n */\n\n\nconst isWebReadableStream = value => {\n  return value && typeof\n  /** @type {any} */\n  value.getReader === 'function';\n};\n/**\n * @param {any} value\n * @returns {value is NodeReadableStream}\n */\n\n\nconst isNodeReadableStream = value => Object.prototype.hasOwnProperty.call(value, 'readable') && Object.prototype.hasOwnProperty.call(value, 'writable');\n\nHTTP.HTTPError = HTTPError;\nHTTP.TimeoutError = TimeoutError;\nHTTP.streamToAsyncIterator = fromStream;\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\n\nHTTP.post = (resource, options) => new HTTP(options).post(resource, options);\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\n\n\nHTTP.get = (resource, options) => new HTTP(options).get(resource, options);\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\n\n\nHTTP.put = (resource, options) => new HTTP(options).put(resource, options);\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\n\n\nHTTP.delete = (resource, options) => new HTTP(options).delete(resource, options);\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\n\n\nHTTP.options = (resource, options) => new HTTP(options).options(resource, options);\n\nmodule.exports = HTTP;","map":{"version":3,"sources":["/home/legasi/nft-marketplace/node_modules/ipfs-utils/src/http.js"],"names":["fetch","Request","Headers","require","TimeoutError","HTTPError","merge","bind","ignoreUndefined","URL","URLSearchParams","anySignal","browserReableStreamToIt","isBrowser","isWebWorker","all","timeout","promise","ms","abortController","undefined","start","Date","now","timedOut","time","Promise","resolve","reject","timeoutID","setTimeout","abort","after","next","fn","res","clearTimeout","then","defaults","throwHttpErrors","credentials","HTTP","constructor","options","opts","resource","headers","TypeError","url","toString","base","searchParams","transformSearchParams","json","search","body","JSON","stringify","set","AbortController","signal","globalThis","ReadableStream","Blob","response","duplex","ok","handleError","iterator","fromStream","ndjson","chunk","transform","post","method","get","put","delete","source","decoder","TextDecoder","buf","decode","stream","lines","split","i","length","l","trim","parse","isAsyncIterable","isNodeReadableStream","iter","Symbol","asyncIterator","return","value","destroy","done","isWebReadableStream","reader","getReader","read","releaseLock","Object","prototype","hasOwnProperty","call","streamToAsyncIterator","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable no-undef */\n'use strict'\n\nconst { fetch, Request, Headers } = require('./http/fetch')\nconst { TimeoutError, HTTPError } = require('./http/error')\nconst merge = require('merge-options').bind({ ignoreUndefined: true })\nconst { URL, URLSearchParams } = require('iso-url')\nconst anySignal = require('any-signal')\nconst browserReableStreamToIt = require('browser-readablestream-to-it')\nconst { isBrowser, isWebWorker } = require('./env')\nconst all = require('it-all')\n\n/**\n * @typedef {import('stream').Readable} NodeReadableStream\n * @typedef {import('./types').HTTPOptions} HTTPOptions\n * @typedef {import('./types').ExtendedResponse} ExtendedResponse\n */\n\n/**\n * @template TResponse\n * @param {Promise<TResponse>} promise\n * @param {number | undefined} ms\n * @param {AbortController} abortController\n * @returns {Promise<TResponse>}\n */\nconst timeout = (promise, ms, abortController) => {\n  if (ms === undefined) {\n    return promise\n  }\n\n  const start = Date.now()\n\n  const timedOut = () => {\n    const time = Date.now() - start\n\n    return time >= ms\n  }\n\n  return new Promise((resolve, reject) => {\n    const timeoutID = setTimeout(() => {\n      if (timedOut()) {\n        reject(new TimeoutError())\n        abortController.abort()\n      }\n    }, ms)\n\n    /**\n     * @param {(value: any) => void } next\n     */\n    const after = (next) => {\n      /**\n       * @param {any} res\n       */\n      const fn = (res) => {\n        clearTimeout(timeoutID)\n\n        if (timedOut()) {\n          reject(new TimeoutError())\n          return\n        }\n\n        next(res)\n      }\n      return fn\n    }\n\n    promise\n      .then(after(resolve), after(reject))\n  })\n}\n\nconst defaults = {\n  throwHttpErrors: true,\n  credentials: 'same-origin'\n}\n\nclass HTTP {\n  /**\n   *\n   * @param {HTTPOptions} options\n   */\n  constructor (options = {}) {\n    /** @type {HTTPOptions} */\n    this.opts = merge(defaults, options)\n  }\n\n  /**\n   * Fetch\n   *\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<ExtendedResponse>}\n   */\n  async fetch (resource, options = {}) {\n    /** @type {HTTPOptions} */\n    const opts = merge(this.opts, options)\n    // @ts-expect-error\n    const headers = new Headers(opts.headers)\n\n    // validate resource type\n    // @ts-expect-error\n    if (typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request)) {\n      throw new TypeError('`resource` must be a string, URL, or Request')\n    }\n\n    const url = new URL(resource.toString(), opts.base)\n\n    const {\n      searchParams,\n      transformSearchParams,\n      json\n    } = opts\n\n    if (searchParams) {\n      if (typeof transformSearchParams === 'function') {\n        // @ts-ignore\n        url.search = transformSearchParams(new URLSearchParams(opts.searchParams))\n      } else {\n        // @ts-ignore\n        url.search = new URLSearchParams(opts.searchParams)\n      }\n    }\n\n    if (json) {\n      opts.body = JSON.stringify(opts.json)\n      headers.set('content-type', 'application/json')\n    }\n\n    const abortController = new AbortController()\n    // @ts-ignore\n    const signal = anySignal([abortController.signal, opts.signal])\n\n    if (globalThis.ReadableStream != null && opts.body instanceof globalThis.ReadableStream && (isBrowser || isWebWorker)) {\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1387483\n      opts.body = new Blob(await all(browserReableStreamToIt(opts.body)))\n    }\n\n    /** @type {ExtendedResponse} */\n    // @ts-expect-error additional fields are assigned below\n    const response = await timeout(\n      fetch(\n        url.toString(),\n        {\n          ...opts,\n          signal,\n          // @ts-expect-error non-browser fetch implementations may take extra options\n          timeout: undefined,\n          headers,\n\n          // https://fetch.spec.whatwg.org/#dom-requestinit-duplex\n          // https://github.com/whatwg/fetch/issues/1254\n          duplex: 'half'\n        }\n      ),\n      opts.timeout,\n      abortController\n    )\n\n    if (!response.ok && opts.throwHttpErrors) {\n      if (opts.handleError) {\n        await opts.handleError(response)\n      }\n      throw new HTTPError(response)\n    }\n\n    response.iterator = async function * () {\n      yield * fromStream(response.body)\n    }\n\n    response.ndjson = async function * () {\n      for await (const chunk of ndjson(response.iterator())) {\n        if (options.transform) {\n          yield options.transform(chunk)\n        } else {\n          yield chunk\n        }\n      }\n    }\n\n    return response\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  post (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'POST' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  get (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'GET' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  put (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'PUT' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  delete (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'DELETE' })\n  }\n\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   */\n  options (resource, options = {}) {\n    return this.fetch(resource, { ...options, method: 'OPTIONS' })\n  }\n}\n\n/**\n * Parses NDJSON chunks from an iterator\n *\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {AsyncIterable<any>}\n */\nconst ndjson = async function * (source) {\n  const decoder = new TextDecoder()\n  let buf = ''\n\n  for await (const chunk of source) {\n    buf += decoder.decode(chunk, { stream: true })\n    const lines = buf.split(/\\r?\\n/)\n\n    for (let i = 0; i < lines.length - 1; i++) {\n      const l = lines[i].trim()\n      if (l.length > 0) {\n        yield JSON.parse(l)\n      }\n    }\n    buf = lines[lines.length - 1]\n  }\n  buf += decoder.decode()\n  buf = buf.trim()\n  if (buf.length !== 0) {\n    yield JSON.parse(buf)\n  }\n}\n\n/**\n * Stream to AsyncIterable\n *\n * @template TChunk\n * @param {ReadableStream<TChunk> | NodeReadableStream | null} source\n * @returns {AsyncIterable<TChunk>}\n */\nconst fromStream = (source) => {\n  if (isAsyncIterable(source)) {\n    return source\n  }\n\n  // Workaround for https://github.com/node-fetch/node-fetch/issues/766\n  if (isNodeReadableStream(source)) {\n    const iter = source[Symbol.asyncIterator]()\n    return {\n      [Symbol.asyncIterator] () {\n        return {\n          next: iter.next.bind(iter),\n          return (value) {\n            source.destroy()\n            if (typeof iter.return === 'function') {\n              return iter.return()\n            }\n            return Promise.resolve({ done: true, value })\n          }\n        }\n      }\n    }\n  }\n\n  if (isWebReadableStream(source)) {\n    const reader = source.getReader()\n    return (async function * () {\n      try {\n        while (true) {\n          // Read from the stream\n          const { done, value } = await reader.read()\n          // Exit if we're done\n          if (done) return\n          // Else yield the chunk\n          if (value) {\n            yield value\n          }\n        }\n      } finally {\n        reader.releaseLock()\n      }\n    })()\n  }\n\n  throw new TypeError('Body can\\'t be converted to AsyncIterable')\n}\n\n/**\n * Check if it's an AsyncIterable\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|AsyncIterable<TChunk>} value\n * @returns {value is AsyncIterable<TChunk>}\n */\nconst isAsyncIterable = (value) => {\n  return typeof value === 'object' &&\n  value !== null &&\n  typeof /** @type {any} */(value)[Symbol.asyncIterator] === 'function'\n}\n\n/**\n * Check for web readable stream\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|ReadableStream<TChunk>} value\n * @returns {value is ReadableStream<TChunk>}\n */\nconst isWebReadableStream = (value) => {\n  return value && typeof /** @type {any} */(value).getReader === 'function'\n}\n\n/**\n * @param {any} value\n * @returns {value is NodeReadableStream}\n */\nconst isNodeReadableStream = (value) =>\n  Object.prototype.hasOwnProperty.call(value, 'readable') &&\n  Object.prototype.hasOwnProperty.call(value, 'writable')\n\nHTTP.HTTPError = HTTPError\nHTTP.TimeoutError = TimeoutError\nHTTP.streamToAsyncIterator = fromStream\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.post = (resource, options) => new HTTP(options).post(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.get = (resource, options) => new HTTP(options).get(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.put = (resource, options) => new HTTP(options).put(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.delete = (resource, options) => new HTTP(options).delete(resource, options)\n\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n */\nHTTP.options = (resource, options) => new HTTP(options).options(resource, options)\n\nmodule.exports = HTTP\n"]},"metadata":{},"sourceType":"script"}