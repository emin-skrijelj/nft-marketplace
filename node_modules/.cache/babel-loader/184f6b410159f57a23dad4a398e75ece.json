{"ast":null,"code":"import basex from '../../vendor/base-x.js';\nimport { coerce } from '../bytes.js'; // Linter can't see that API is used in types.\n// eslint-disable-next-line\n\nimport * as API from './interface.js';\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\n\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n\n\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n\n}\n/**\n * @template {string} Prefix\n */\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\n\n\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    /* c8 ignore next 3 */\n\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character');\n    }\n    /** @private */\n\n\n    this.prefixCodePoint =\n    /** @type {number} */\n    prefix.codePointAt(0);\n    this.baseDecode = baseDecode;\n  }\n  /**\n   * @param {string} text\n   */\n\n\n  decode(text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      }\n\n      return this.baseDecode(text.slice(this.prefix.length));\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n\n\n  or(decoder) {\n    return or(this, decoder);\n  }\n\n}\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\n\n\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n\n\n  or(decoder) {\n    return or(this, decoder);\n  }\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n\n\n  decode(input) {\n    const prefix =\n    /** @type {Prefix} */\n    input[0];\n    const decoder = this.decoders[prefix];\n\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n    }\n  }\n\n}\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\n\n\nexport const or = (left, right) => new ComposedDecoder(\n/** @type {Decoders<L|R>} */\n{ ...(left.decoders || {\n    [\n    /** @type API.UnibaseDecoder<L> */\n    left.prefix]: left\n  }),\n  ...(right.decoders || {\n    [\n    /** @type API.UnibaseDecoder<R> */\n    right.prefix]: right\n  })\n});\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\n\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n  /**\n   * @param {Uint8Array} input\n   */\n\n\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  /**\n   * @param {string} input\n   */\n\n\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n\n}\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\n\nexport const from = _ref => {\n  let {\n    name,\n    prefix,\n    encode,\n    decode\n  } = _ref;\n  return new Codec(name, prefix, encode, decode);\n};\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\n\nexport const baseX = _ref2 => {\n  let {\n    prefix,\n    name,\n    alphabet\n  } = _ref2;\n  const {\n    encode,\n    decode\n  } = basex(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  });\n};\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\n\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n\n  /** @type {Record<string, number>} */\n  const codes = {};\n\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  } // Count the padding bytes:\n\n\n  let end = string.length;\n\n  while (string[end - 1] === '=') {\n    --end;\n  } // Allocate the output:\n\n\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0); // Parse the data:\n\n  let bits = 0; // Number of bits currently in the buffer\n\n  let buffer = 0; // Bits waiting to be written out, MSB first\n\n  let written = 0; // Next byte to write\n\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]];\n\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`);\n    } // Append the bits to the buffer:\n\n\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar; // Write out some bits if the buffer has a byte's worth:\n\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 0xff & buffer >> bits;\n    }\n  } // Verify that we have received just enough bits:\n\n\n  if (bits >= bitsPerChar || 0xff & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n\n  return out;\n};\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\n\n\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0; // Number of bits currently in the buffer\n\n  let buffer = 0; // Bits waiting to be written out, MSB first\n\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = buffer << 8 | data[i];\n    bits += 8; // Write out as much as we can:\n\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  } // Partial character:\n\n\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  } // Add padding characters until we hit a byte boundary:\n\n\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n\n  return out;\n};\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\n\n\nexport const rfc4648 = _ref3 => {\n  let {\n    name,\n    prefix,\n    bitsPerChar,\n    alphabet\n  } = _ref3;\n  return from({\n    prefix,\n    name,\n\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n\n  });\n};","map":{"version":3,"sources":["/home/legasi/nft-marketplace/node_modules/multiformats/src/bases/base.js"],"names":["basex","coerce","API","Encoder","constructor","name","prefix","baseEncode","encode","bytes","Uint8Array","Error","Decoder","baseDecode","codePointAt","undefined","prefixCodePoint","decode","text","JSON","stringify","slice","length","or","decoder","ComposedDecoder","decoders","input","RangeError","Object","keys","left","right","Codec","encoder","from","baseX","alphabet","string","bitsPerChar","codes","i","end","out","bits","buffer","written","value","SyntaxError","data","pad","mask","rfc4648"],"mappings":"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","sourcesContent":["import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"module"}