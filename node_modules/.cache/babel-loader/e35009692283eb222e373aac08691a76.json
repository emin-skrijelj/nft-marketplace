{"ast":null,"code":"import { IPv4Len, IPv6Len } from \"./ip.js\";\nexport function allFF(a, from, to) {\n  let i = 0;\n\n  for (const e of a) {\n    if (i < from) continue;\n    if (i > to) break;\n    if (e !== 0xff) return false;\n    i++;\n  }\n\n  return true;\n}\nexport function deepEqual(a, b, from, to) {\n  let i = 0;\n\n  for (const e of a) {\n    if (i < from) continue;\n    if (i > to) break;\n    if (e !== b[i]) return false;\n    i++;\n  }\n\n  return true;\n}\n/***\n * Returns long ip format\n */\n\nexport function ipToString(ip) {\n  switch (ip.length) {\n    case IPv4Len:\n      {\n        return ip.join(\".\");\n      }\n\n    case IPv6Len:\n      {\n        const result = [];\n\n        for (let i = 0; i < ip.length; i++) {\n          if (i % 2 === 0) {\n            result.push(ip[i].toString(16).padStart(2, \"0\") + ip[i + 1].toString(16).padStart(2, \"0\"));\n          }\n        }\n\n        return result.join(\":\");\n      }\n\n    default:\n      {\n        throw new Error(\"Invalid ip length\");\n      }\n  }\n}\n/**\n * If mask is a sequence of 1 bits followed by 0 bits, return number of 1 bits else -1\n */\n\nexport function simpleMaskLength(mask) {\n  let ones = 0; // eslint-disable-next-line prefer-const\n\n  for (let [index, byte] of mask.entries()) {\n    if (byte === 0xff) {\n      ones += 8;\n      continue;\n    }\n\n    while ((byte & 0x80) != 0) {\n      ones++;\n      byte = byte << 1;\n    }\n\n    if ((byte & 0x80) != 0) {\n      return -1;\n    }\n\n    for (let i = index + 1; i < mask.length; i++) {\n      if (mask[i] != 0) {\n        return -1;\n      }\n    }\n\n    break;\n  }\n\n  return ones;\n}\nexport function maskToHex(mask) {\n  let hex = \"0x\";\n\n  for (const byte of mask) {\n    hex += (byte >> 4).toString(16) + (byte & 0x0f).toString(16);\n  }\n\n  return hex;\n}","map":{"version":3,"mappings":"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","names":["IPv4Len","IPv6Len","allFF","a","from","to","i","e","deepEqual","b","ipToString","ip","length","join","result","push","toString","padStart","Error","simpleMaskLength","mask","ones","index","byte","entries","maskToHex","hex"],"sources":["/home/legasi/nft-marketplace/node_modules/@chainsafe/netmask/src/util.ts"],"sourcesContent":["import { IPv4Len, IPv6Len } from \"./ip.js\";\n\nexport function allFF(\n  a: number[] | Uint8Array,\n  from: number,\n  to: number\n): boolean {\n  let i = 0;\n  for (const e of a) {\n    if (i < from) continue;\n    if (i > to) break;\n    if (e !== 0xff) return false;\n    i++;\n  }\n  return true;\n}\n\nexport function deepEqual(\n  a: Uint8Array | number[],\n  b: Uint8Array,\n  from: number,\n  to: number\n): boolean {\n  let i = 0;\n  for (const e of a) {\n    if (i < from) continue;\n    if (i > to) break;\n    if (e !== b[i]) return false;\n    i++;\n  }\n  return true;\n}\n\n/***\n * Returns long ip format\n */\nexport function ipToString(ip: Uint8Array | number[]): string {\n  switch (ip.length) {\n    case IPv4Len: {\n      return ip.join(\".\");\n    }\n    case IPv6Len: {\n      const result = [] as string[];\n      for (let i = 0; i < ip.length; i++) {\n        if (i % 2 === 0) {\n          result.push(\n            ip[i].toString(16).padStart(2, \"0\") +\n              ip[i + 1].toString(16).padStart(2, \"0\")\n          );\n        }\n      }\n      return result.join(\":\");\n    }\n    default: {\n      throw new Error(\"Invalid ip length\");\n    }\n  }\n}\n\n/**\n * If mask is a sequence of 1 bits followed by 0 bits, return number of 1 bits else -1\n */\nexport function simpleMaskLength(mask: Uint8Array): number {\n  let ones = 0;\n  // eslint-disable-next-line prefer-const\n  for (let [index, byte] of mask.entries()) {\n    if (byte === 0xff) {\n      ones += 8;\n      continue;\n    }\n    while ((byte & 0x80) != 0) {\n      ones++;\n      byte = byte << 1;\n    }\n    if ((byte & 0x80) != 0) {\n      return -1;\n    }\n    for (let i = index + 1; i < mask.length; i++) {\n      if (mask[i] != 0) {\n        return -1;\n      }\n    }\n    break;\n  }\n  return ones;\n}\n\nexport function maskToHex(mask: Uint8Array): string {\n  let hex = \"0x\";\n  for (const byte of mask) {\n    hex += (byte >> 4).toString(16) + (byte & 0x0f).toString(16);\n  }\n  return hex;\n}\n"]},"metadata":{},"sourceType":"module"}