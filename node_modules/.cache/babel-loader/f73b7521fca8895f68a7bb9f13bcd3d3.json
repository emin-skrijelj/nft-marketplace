{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-unsafe-return */\nexport class Parser {\n  index = 0;\n  input = \"\";\n\n  new(input) {\n    this.index = 0;\n    this.input = input;\n    return this;\n  }\n  /** Run a parser, and restore the pre-parse state if it fails. */\n\n\n  readAtomically(fn) {\n    const index = this.index;\n    const result = fn();\n\n    if (result === undefined) {\n      this.index = index;\n    }\n\n    return result;\n  }\n  /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */\n\n\n  parseWith(fn) {\n    const result = fn();\n\n    if (this.index !== this.input.length) {\n      return undefined;\n    }\n\n    return result;\n  }\n  /** Peek the next character from the input */\n\n\n  peekChar() {\n    if (this.index >= this.input.length) {\n      return undefined;\n    }\n\n    return this.input[this.index];\n  }\n  /** Read the next character from the input */\n\n\n  readChar() {\n    if (this.index >= this.input.length) {\n      return undefined;\n    }\n\n    return this.input[this.index++];\n  }\n  /** Read the next character from the input if it matches the target. */\n\n\n  readGivenChar(target) {\n    return this.readAtomically(() => {\n      const char = this.readChar();\n\n      if (char !== target) {\n        return undefined;\n      }\n\n      return char;\n    });\n  }\n  /**\n   * Helper for reading separators in an indexed loop. Reads the separator\n   * character iff index > 0, then runs the parser. When used in a loop,\n   * the separator character will only be read on index > 0 (see\n   * readIPv4Addr for an example)\n   */\n\n\n  readSeparator(sep, index, inner) {\n    return this.readAtomically(() => {\n      if (index > 0) {\n        if (this.readGivenChar(sep) === undefined) {\n          return undefined;\n        }\n      }\n\n      return inner();\n    });\n  }\n  /**\n   * Read a number off the front of the input in the given radix, stopping\n   * at the first non-digit character or eof. Fails if the number has more\n   * digits than max_digits or if there is no number.\n   */\n\n\n  readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {\n    return this.readAtomically(() => {\n      let result = 0;\n      let digitCount = 0;\n      const leadingChar = this.peekChar();\n\n      if (leadingChar === undefined) {\n        return undefined;\n      }\n\n      const hasLeadingZero = leadingChar === \"0\";\n      const maxValue = 2 ** (8 * maxBytes) - 1; // eslint-disable-next-line no-constant-condition\n\n      while (true) {\n        const digit = this.readAtomically(() => {\n          const char = this.readChar();\n\n          if (char === undefined) {\n            return undefined;\n          }\n\n          const num = Number.parseInt(char, radix);\n\n          if (Number.isNaN(num)) {\n            return undefined;\n          }\n\n          return num;\n        });\n\n        if (digit === undefined) {\n          break;\n        }\n\n        result *= radix;\n        result += digit;\n\n        if (result > maxValue) {\n          return undefined;\n        }\n\n        digitCount += 1;\n\n        if (maxDigits !== undefined) {\n          if (digitCount > maxDigits) {\n            return undefined;\n          }\n        }\n      }\n\n      if (digitCount === 0) {\n        return undefined;\n      } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {\n        return undefined;\n      } else {\n        return result;\n      }\n    });\n  }\n  /** Read an IPv4 address. */\n\n\n  readIPv4Addr() {\n    return this.readAtomically(() => {\n      const out = new Uint8Array(4);\n\n      for (let i = 0; i < out.length; i++) {\n        const ix = this.readSeparator(\".\", i, () => this.readNumber(10, 3, false, 1));\n\n        if (ix === undefined) {\n          return undefined;\n        }\n\n        out[i] = ix;\n      }\n\n      return out;\n    });\n  }\n  /** Read an IPv6 Address. */\n\n\n  readIPv6Addr() {\n    /**\n     * Read a chunk of an IPv6 address into `groups`. Returns the number\n     * of groups read, along with a bool indicating if an embedded\n     * trailing IPv4 address was read. Specifically, read a series of\n     * colon-separated IPv6 groups (0x0000 - 0xFFFF), with an optional\n     * trailing embedded IPv4 address.\n     */\n    const readGroups = groups => {\n      for (let i = 0; i < groups.length / 2; i++) {\n        const ix = i * 2; // Try to read a trailing embedded IPv4 address. There must be at least 4 groups left.\n\n        if (i < groups.length - 3) {\n          const ipv4 = this.readSeparator(\":\", i, () => this.readIPv4Addr());\n\n          if (ipv4 !== undefined) {\n            groups[ix] = ipv4[0];\n            groups[ix + 1] = ipv4[1];\n            groups[ix + 2] = ipv4[2];\n            groups[ix + 3] = ipv4[3];\n            return [ix + 4, true];\n          }\n        }\n\n        const group = this.readSeparator(\":\", i, () => this.readNumber(16, 4, true, 2));\n\n        if (group === undefined) {\n          return [ix, false];\n        }\n\n        groups[ix] = group >> 8;\n        groups[ix + 1] = group & 255;\n      }\n\n      return [groups.length, false];\n    };\n\n    return this.readAtomically(() => {\n      // Read the front part of the address; either the whole thing, or up to the first ::\n      const head = new Uint8Array(16);\n      const [headSize, headIp4] = readGroups(head);\n\n      if (headSize === 16) {\n        return head;\n      } // IPv4 part is not allowed before `::`\n\n\n      if (headIp4) {\n        return undefined;\n      } // Read `::` if previous code parsed less than 8 groups.\n      // `::` indicates one or more groups of 16 bits of zeros.\n\n\n      if (this.readGivenChar(\":\") === undefined) {\n        return undefined;\n      }\n\n      if (this.readGivenChar(\":\") === undefined) {\n        return undefined;\n      } // Read the back part of the address. The :: must contain at least one\n      // set of zeroes, so our max length is 7.\n\n\n      const tail = new Uint8Array(14);\n      const limit = 16 - (headSize + 2);\n      const [tailSize] = readGroups(tail.subarray(0, limit)); // Concat the head and tail of the IP address\n\n      head.set(tail.subarray(0, tailSize), 16 - tailSize);\n      return head;\n    });\n  }\n  /** Read an IP Address, either IPv4 or IPv6. */\n\n\n  readIPAddr() {\n    return this.readIPv4Addr() ?? this.readIPv6Addr();\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Parser","index","input","new","readAtomically","fn","result","undefined","parseWith","length","peekChar","readChar","readGivenChar","target","char","readSeparator","sep","inner","readNumber","radix","maxDigits","allowZeroPrefix","maxBytes","digitCount","leadingChar","hasLeadingZero","maxValue","digit","num","Number","parseInt","isNaN","readIPv4Addr","out","Uint8Array","i","ix","readIPv6Addr","readGroups","groups","ipv4","group","head","headSize","headIp4","tail","limit","tailSize","subarray","set","readIPAddr"],"sources":["../src/parser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}