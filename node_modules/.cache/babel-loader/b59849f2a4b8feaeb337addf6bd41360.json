{"ast":null,"code":"import { parseIP } from \"@chainsafe/is-ip/parse\";\nimport { allFF, deepEqual } from \"./util.js\";\nexport const IPv4Len = 4;\nexport const IPv6Len = 16;\nexport const maxIPv6Octet = parseInt(\"0xFFFF\", 16);\nexport const ipv4Prefix = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255]);\nexport function maskIp(ip, mask) {\n  if (mask.length === IPv6Len && ip.length === IPv4Len && allFF(mask, 0, 11)) {\n    mask = mask.slice(12);\n  }\n\n  if (mask.length === IPv4Len && ip.length === IPv6Len && deepEqual(ip, ipv4Prefix, 0, 11)) {\n    ip = ip.slice(12);\n  }\n\n  const n = ip.length;\n\n  if (n != mask.length) {\n    throw new Error(\"Failed to mask ip\");\n  }\n\n  const out = new Uint8Array(n);\n\n  for (let i = 0; i < n; i++) {\n    out[i] = ip[i] & mask[i];\n  }\n\n  return out;\n}\nexport function containsIp(net, ip) {\n  if (typeof ip === \"string\") {\n    ip = parseIP(ip);\n  }\n\n  if (ip == null) throw new Error(\"Invalid ip\");\n\n  if (ip.length !== net.network.length) {\n    return false;\n  }\n\n  for (let i = 0; i < ip.length; i++) {\n    if ((net.network[i] & net.mask[i]) !== (ip[i] & net.mask[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function iPv4FromIPv6(ip) {\n  if (!isIPv4mappedIPv6(ip)) {\n    throw new Error(\"Must have 0xffff prefix\");\n  }\n\n  return ip.slice(12);\n}\nexport function isIPv4mappedIPv6(ip) {\n  return deepEqual(ip, ipv4Prefix, 0, 11);\n}","map":{"version":3,"mappings":"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","names":["parseIP","allFF","deepEqual","IPv4Len","IPv6Len","maxIPv6Octet","parseInt","ipv4Prefix","Uint8Array","maskIp","ip","mask","length","slice","n","Error","out","i","containsIp","net","network","iPv4FromIPv6","isIPv4mappedIPv6"],"sources":["/home/legasi/nft-marketplace/node_modules/@chainsafe/netmask/src/ip.ts"],"sourcesContent":["import { parseIP } from \"@chainsafe/is-ip/parse\";\nimport { allFF, deepEqual } from \"./util.js\";\n\nexport const IPv4Len = 4;\nexport const IPv6Len = 16;\n\nexport const maxIPv6Octet = parseInt(\"0xFFFF\", 16);\nexport const ipv4Prefix = new Uint8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255,\n]);\n\nexport interface IpNetRaw {\n  network: Uint8Array;\n  mask: Uint8Array;\n}\n\nexport function maskIp(ip: Uint8Array, mask: Uint8Array): Uint8Array {\n  if (mask.length === IPv6Len && ip.length === IPv4Len && allFF(mask, 0, 11)) {\n    mask = mask.slice(12);\n  }\n  if (\n    mask.length === IPv4Len &&\n    ip.length === IPv6Len &&\n    deepEqual(ip, ipv4Prefix, 0, 11)\n  ) {\n    ip = ip.slice(12);\n  }\n  const n = ip.length;\n  if (n != mask.length) {\n    throw new Error(\"Failed to mask ip\");\n  }\n  const out = new Uint8Array(n);\n  for (let i = 0; i < n; i++) {\n    out[i] = ip[i] & mask[i];\n  }\n  return out;\n}\n\nexport function containsIp(\n  net: IpNetRaw,\n  ip: Uint8Array | number[] | string\n): boolean {\n  if (typeof ip === \"string\") {\n    ip = parseIP(ip)!;\n  }\n  if (ip == null) throw new Error(\"Invalid ip\");\n  if (ip.length !== net.network.length) {\n    return false;\n  }\n  for (let i = 0; i < ip.length; i++) {\n    if ((net.network[i] & net.mask[i]) !== (ip[i] & net.mask[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function iPv4FromIPv6(ip: Uint8Array): Uint8Array {\n  if (!isIPv4mappedIPv6(ip)) {\n    throw new Error(\"Must have 0xffff prefix\");\n  }\n  return ip.slice(12);\n}\n\nexport function isIPv4mappedIPv6(ip: Uint8Array | number[]): boolean {\n  return deepEqual(ip, ipv4Prefix, 0, 11);\n}\n"]},"metadata":{},"sourceType":"module"}