{"ast":null,"code":"import { symbol } from '@libp2p/interface-peer-id';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst baseDecoder = Object.values(bases).map(codec => codec.decoder) // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n.reduce((acc, curr) => acc.or(curr), bases.identity.decoder); // these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\n\nconst LIBP2P_KEY_CODE = 0x72;\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\n\nclass PeerIdImpl {\n  type;\n  multihash;\n  privateKey;\n  publicKey;\n  string;\n\n  constructor(init) {\n    this.type = init.type;\n    this.multihash = init.multihash;\n    this.privateKey = init.privateKey; // mark string cache as non-enumerable\n\n    Object.defineProperty(this, 'string', {\n      enumerable: false,\n      writable: true\n    });\n  }\n\n  get [Symbol.toStringTag]() {\n    return `PeerId(${this.toString()})`;\n  }\n\n  [symbol] = true;\n\n  toString() {\n    if (this.string == null) {\n      this.string = base58btc.encode(this.multihash.bytes).slice(1);\n    }\n\n    return this.string;\n  } // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n\n\n  toCID() {\n    return CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n  }\n\n  toBytes() {\n    return this.multihash.bytes;\n  }\n  /**\n   * Returns Multiaddr as a JSON string\n   */\n\n\n  toJSON() {\n    return this.toString();\n  }\n  /**\n   * Checks the equality of `this` peer against a given PeerId\n   */\n\n\n  equals(id) {\n    if (id instanceof Uint8Array) {\n      return uint8ArrayEquals(this.multihash.bytes, id);\n    } else if (typeof id === 'string') {\n      return peerIdFromString(id).equals(this);\n    } else if (id?.multihash?.bytes != null) {\n      return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes);\n    } else {\n      throw new Error('not valid Id');\n    }\n  }\n  /**\n   * Returns PeerId as a human-readable string\n   * https://nodejs.org/api/util.html#utilinspectcustom\n   *\n   * @example\n   * ```js\n   * import { peerIdFromString } from '@libp2p/peer-id'\n   *\n   * console.info(peerIdFromString('QmFoo'))\n   * // 'PeerId(QmFoo)'\n   * ```\n   */\n\n\n  [inspect]() {\n    return `PeerId(${this.toString()})`;\n  }\n\n}\n\nclass RSAPeerIdImpl extends PeerIdImpl {\n  type = 'RSA';\n  publicKey;\n\n  constructor(init) {\n    super({ ...init,\n      type: 'RSA'\n    });\n    this.publicKey = init.publicKey;\n  }\n\n}\n\nclass Ed25519PeerIdImpl extends PeerIdImpl {\n  type = 'Ed25519';\n  publicKey;\n\n  constructor(init) {\n    super({ ...init,\n      type: 'Ed25519'\n    });\n    this.publicKey = init.multihash.digest;\n  }\n\n}\n\nclass Secp256k1PeerIdImpl extends PeerIdImpl {\n  type = 'secp256k1';\n  publicKey;\n\n  constructor(init) {\n    super({ ...init,\n      type: 'secp256k1'\n    });\n    this.publicKey = init.multihash.digest;\n  }\n\n}\n\nexport function createPeerId(init) {\n  if (init.type === 'RSA') {\n    return new RSAPeerIdImpl(init);\n  }\n\n  if (init.type === 'Ed25519') {\n    return new Ed25519PeerIdImpl(init);\n  }\n\n  if (init.type === 'secp256k1') {\n    return new Secp256k1PeerIdImpl(init);\n  }\n\n  throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromPeerId(other) {\n  if (other.type === 'RSA') {\n    return new RSAPeerIdImpl(other);\n  }\n\n  if (other.type === 'Ed25519') {\n    return new Ed25519PeerIdImpl(other);\n  }\n\n  if (other.type === 'secp256k1') {\n    return new Secp256k1PeerIdImpl(other);\n  }\n\n  throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromString(str, decoder) {\n  decoder = decoder ?? baseDecoder;\n\n  if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n    // identity hash ed25519/secp256k1 key or sha2-256 hash of\n    // rsa public key - base58btc encoded either way\n    const multihash = Digest.decode(base58btc.decode(`z${str}`));\n\n    if (str.startsWith('12D')) {\n      return new Ed25519PeerIdImpl({\n        multihash\n      });\n    } else if (str.startsWith('16U')) {\n      return new Secp256k1PeerIdImpl({\n        multihash\n      });\n    } else {\n      return new RSAPeerIdImpl({\n        multihash\n      });\n    }\n  }\n\n  return peerIdFromBytes(baseDecoder.decode(str));\n}\nexport function peerIdFromBytes(buf) {\n  try {\n    const multihash = Digest.decode(buf);\n\n    if (multihash.code === identity.code) {\n      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({\n          multihash\n        });\n      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({\n          multihash\n        });\n      }\n    }\n\n    if (multihash.code === sha256.code) {\n      return new RSAPeerIdImpl({\n        multihash\n      });\n    }\n  } catch {\n    return peerIdFromCID(CID.decode(buf));\n  }\n\n  throw new Error('Supplied PeerID CID is invalid');\n}\nexport function peerIdFromCID(cid) {\n  if (cid == null || cid.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE) {\n    throw new Error('Supplied PeerID CID is invalid');\n  }\n\n  const multihash = cid.multihash;\n\n  if (multihash.code === sha256.code) {\n    return new RSAPeerIdImpl({\n      multihash: cid.multihash\n    });\n  } else if (multihash.code === identity.code) {\n    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n      return new Ed25519PeerIdImpl({\n        multihash: cid.multihash\n      });\n    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n      return new Secp256k1PeerIdImpl({\n        multihash: cid.multihash\n      });\n    }\n  }\n\n  throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\n\nexport async function peerIdFromKeys(publicKey, privateKey) {\n  if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n    return new Ed25519PeerIdImpl({\n      multihash: Digest.create(identity.code, publicKey),\n      privateKey\n    });\n  }\n\n  if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n    return new Secp256k1PeerIdImpl({\n      multihash: Digest.create(identity.code, publicKey),\n      privateKey\n    });\n  }\n\n  return new RSAPeerIdImpl({\n    multihash: await sha256.digest(publicKey),\n    publicKey,\n    privateKey\n  });\n}","map":{"version":3,"mappings":"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","names":["symbol","CodeError","base58btc","bases","CID","Digest","identity","sha256","equals","uint8ArrayEquals","inspect","Symbol","for","baseDecoder","Object","values","map","codec","decoder","reduce","acc","curr","or","LIBP2P_KEY_CODE","MARSHALLED_ED225519_PUBLIC_KEY_LENGTH","MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH","PeerIdImpl","type","multihash","privateKey","publicKey","string","constructor","init","defineProperty","enumerable","writable","toStringTag","toString","encode","bytes","slice","toCID","createV1","toBytes","toJSON","id","Uint8Array","peerIdFromString","Error","RSAPeerIdImpl","Ed25519PeerIdImpl","digest","Secp256k1PeerIdImpl","createPeerId","peerIdFromPeerId","other","str","charAt","decode","startsWith","peerIdFromBytes","buf","code","length","peerIdFromCID","cid","version","peerIdFromKeys","create"],"sources":["/home/legasi/nft-marketplace/node_modules/@libp2p/peer-id/src/index.ts"],"sourcesContent":["import { type Ed25519PeerId, type PeerIdType, type RSAPeerId, type Secp256k1PeerId, symbol, type PeerId } from '@libp2p/interface-peer-id'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { bases } from 'multiformats/basics'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { identity } from 'multiformats/hashes/identity'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport type { MultibaseDecoder } from 'multiformats/bases/interface'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\n\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\n\nconst baseDecoder = Object\n  .values(bases)\n  .map(codec => codec.decoder)\n  // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n  .reduce((acc, curr) => acc.or(curr), bases.identity.decoder)\n\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72\n\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37\n\ninterface PeerIdInit {\n  type: PeerIdType\n  multihash: MultihashDigest\n  privateKey?: Uint8Array\n}\n\ninterface RSAPeerIdInit {\n  multihash: MultihashDigest\n  privateKey?: Uint8Array\n  publicKey?: Uint8Array\n}\n\ninterface Ed25519PeerIdInit {\n  multihash: MultihashDigest\n  privateKey?: Uint8Array\n}\n\ninterface Secp256k1PeerIdInit {\n  multihash: MultihashDigest\n  privateKey?: Uint8Array\n}\n\nclass PeerIdImpl {\n  public type: PeerIdType\n  public readonly multihash: MultihashDigest\n  public readonly privateKey?: Uint8Array\n  public readonly publicKey?: Uint8Array\n  private string?: string\n\n  constructor (init: PeerIdInit) {\n    this.type = init.type\n    this.multihash = init.multihash\n    this.privateKey = init.privateKey\n\n    // mark string cache as non-enumerable\n    Object.defineProperty(this, 'string', {\n      enumerable: false,\n      writable: true\n    })\n  }\n\n  get [Symbol.toStringTag] (): string {\n    return `PeerId(${this.toString()})`\n  }\n\n  readonly [symbol] = true\n\n  toString (): string {\n    if (this.string == null) {\n      this.string = base58btc.encode(this.multihash.bytes).slice(1)\n    }\n\n    return this.string\n  }\n\n  // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n  toCID (): CID {\n    return CID.createV1(LIBP2P_KEY_CODE, this.multihash)\n  }\n\n  toBytes (): Uint8Array {\n    return this.multihash.bytes\n  }\n\n  /**\n   * Returns Multiaddr as a JSON string\n   */\n  toJSON (): string {\n    return this.toString()\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId\n   */\n  equals (id: PeerId | Uint8Array | string): boolean {\n    if (id instanceof Uint8Array) {\n      return uint8ArrayEquals(this.multihash.bytes, id)\n    } else if (typeof id === 'string') {\n      return peerIdFromString(id).equals(this as PeerId)\n    } else if (id?.multihash?.bytes != null) {\n      return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /**\n   * Returns PeerId as a human-readable string\n   * https://nodejs.org/api/util.html#utilinspectcustom\n   *\n   * @example\n   * ```js\n   * import { peerIdFromString } from '@libp2p/peer-id'\n   *\n   * console.info(peerIdFromString('QmFoo'))\n   * // 'PeerId(QmFoo)'\n   * ```\n   */\n  [inspect] (): string {\n    return `PeerId(${this.toString()})`\n  }\n}\n\nclass RSAPeerIdImpl extends PeerIdImpl implements RSAPeerId {\n  public readonly type = 'RSA'\n  public readonly publicKey?: Uint8Array\n\n  constructor (init: RSAPeerIdInit) {\n    super({ ...init, type: 'RSA' })\n\n    this.publicKey = init.publicKey\n  }\n}\n\nclass Ed25519PeerIdImpl extends PeerIdImpl implements Ed25519PeerId {\n  public readonly type = 'Ed25519'\n  public readonly publicKey: Uint8Array\n\n  constructor (init: Ed25519PeerIdInit) {\n    super({ ...init, type: 'Ed25519' })\n\n    this.publicKey = init.multihash.digest\n  }\n}\n\nclass Secp256k1PeerIdImpl extends PeerIdImpl implements Secp256k1PeerId {\n  public readonly type = 'secp256k1'\n  public readonly publicKey: Uint8Array\n\n  constructor (init: Secp256k1PeerIdInit) {\n    super({ ...init, type: 'secp256k1' })\n\n    this.publicKey = init.multihash.digest\n  }\n}\n\nexport function createPeerId (init: PeerIdInit): PeerId {\n  if (init.type === 'RSA') {\n    return new RSAPeerIdImpl(init)\n  }\n\n  if (init.type === 'Ed25519') {\n    return new Ed25519PeerIdImpl(init)\n  }\n\n  if (init.type === 'secp256k1') {\n    return new Secp256k1PeerIdImpl(init)\n  }\n\n  throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS')\n}\n\nexport function peerIdFromPeerId (other: any): PeerId {\n  if (other.type === 'RSA') {\n    return new RSAPeerIdImpl(other)\n  }\n\n  if (other.type === 'Ed25519') {\n    return new Ed25519PeerIdImpl(other)\n  }\n\n  if (other.type === 'secp256k1') {\n    return new Secp256k1PeerIdImpl(other)\n  }\n\n  throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS')\n}\n\nexport function peerIdFromString (str: string, decoder?: MultibaseDecoder<any>): PeerId {\n  decoder = decoder ?? baseDecoder\n\n  if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n    // identity hash ed25519/secp256k1 key or sha2-256 hash of\n    // rsa public key - base58btc encoded either way\n    const multihash = Digest.decode(base58btc.decode(`z${str}`))\n\n    if (str.startsWith('12D')) {\n      return new Ed25519PeerIdImpl({ multihash })\n    } else if (str.startsWith('16U')) {\n      return new Secp256k1PeerIdImpl({ multihash })\n    } else {\n      return new RSAPeerIdImpl({ multihash })\n    }\n  }\n\n  return peerIdFromBytes(baseDecoder.decode(str))\n}\n\nexport function peerIdFromBytes (buf: Uint8Array): PeerId {\n  try {\n    const multihash = Digest.decode(buf)\n\n    if (multihash.code === identity.code) {\n      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash })\n      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash })\n      }\n    }\n\n    if (multihash.code === sha256.code) {\n      return new RSAPeerIdImpl({ multihash })\n    }\n  } catch {\n    return peerIdFromCID(CID.decode(buf))\n  }\n\n  throw new Error('Supplied PeerID CID is invalid')\n}\n\nexport function peerIdFromCID (cid: CID): PeerId {\n  if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n    throw new Error('Supplied PeerID CID is invalid')\n  }\n\n  const multihash = cid.multihash\n\n  if (multihash.code === sha256.code) {\n    return new RSAPeerIdImpl({ multihash: cid.multihash })\n  } else if (multihash.code === identity.code) {\n    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n      return new Ed25519PeerIdImpl({ multihash: cid.multihash })\n    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n      return new Secp256k1PeerIdImpl({ multihash: cid.multihash })\n    }\n  }\n\n  throw new Error('Supplied PeerID CID is invalid')\n}\n\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys (publicKey: Uint8Array, privateKey?: Uint8Array): Promise<PeerId> {\n  if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n    return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey })\n  }\n\n  if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n    return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey })\n  }\n\n  return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey })\n}\n"]},"metadata":{},"sourceType":"module"}