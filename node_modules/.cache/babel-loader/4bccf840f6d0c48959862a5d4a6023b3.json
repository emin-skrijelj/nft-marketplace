{"ast":null,"code":"import { isIPv4, isIPv6 } from '@chainsafe/is-ip';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nexport { isIP } from '@chainsafe/is-ip';\nexport const isV4 = isIPv4;\nexport const isV6 = isIPv6; // Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\n\nexport const toBytes = function (ip) {\n  let offset = 0;\n  ip = ip.toString().trim();\n\n  if (isV4(ip)) {\n    const bytes = new Uint8Array(offset + 4);\n    ip.split(/\\./g).forEach(byte => {\n      bytes[offset++] = parseInt(byte, 10) & 0xff;\n    });\n    return bytes;\n  }\n\n  if (isV6(ip)) {\n    const sections = ip.split(':', 8);\n    let i;\n\n    for (i = 0; i < sections.length; i++) {\n      const isv4 = isV4(sections[i]);\n      let v4Buffer;\n\n      if (isv4) {\n        v4Buffer = toBytes(sections[i]);\n        sections[i] = uint8ArrayToString(v4Buffer.slice(0, 2), 'base16');\n      }\n\n      if (v4Buffer != null && ++i < 8) {\n        sections.splice(i, 0, uint8ArrayToString(v4Buffer.slice(2, 4), 'base16'));\n      }\n    }\n\n    if (sections[0] === '') {\n      while (sections.length < 8) sections.unshift('0');\n    } else if (sections[sections.length - 1] === '') {\n      while (sections.length < 8) sections.push('0');\n    } else if (sections.length < 8) {\n      for (i = 0; i < sections.length && sections[i] !== ''; i++);\n\n      const argv = [i, 1];\n\n      for (i = 9 - sections.length; i > 0; i--) {\n        argv.push('0');\n      }\n\n      sections.splice.apply(sections, argv);\n    }\n\n    const bytes = new Uint8Array(offset + 16);\n\n    for (i = 0; i < sections.length; i++) {\n      const word = parseInt(sections[i], 16);\n      bytes[offset++] = word >> 8 & 0xff;\n      bytes[offset++] = word & 0xff;\n    }\n\n    return bytes;\n  }\n\n  throw new Error('invalid ip address');\n}; // Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63\n\nexport const toString = function (buf) {\n  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let length = arguments.length > 2 ? arguments[2] : undefined;\n  offset = ~~offset;\n  length = length ?? buf.length - offset;\n  const view = new DataView(buf.buffer);\n\n  if (length === 4) {\n    const result = []; // IPv4\n\n    for (let i = 0; i < length; i++) {\n      result.push(buf[offset + i]);\n    }\n\n    return result.join('.');\n  }\n\n  if (length === 16) {\n    const result = []; // IPv6\n\n    for (let i = 0; i < length; i += 2) {\n      result.push(view.getUint16(offset + i).toString(16));\n    }\n\n    return result.join(':').replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3').replace(/:{3,4}/, '::');\n  }\n\n  return '';\n};","map":{"version":3,"mappings":"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","names":["isIPv4","isIPv6","toString","uint8ArrayToString","isIP","isV4","isV6","toBytes","ip","offset","trim","bytes","Uint8Array","split","forEach","byte","parseInt","sections","i","length","isv4","v4Buffer","slice","splice","unshift","push","argv","apply","word","Error","buf","view","DataView","buffer","result","join","getUint16","replace"],"sources":["/home/legasi/nft-marketplace/node_modules/ipfs-http-client/node_modules/@multiformats/multiaddr/src/ip.ts"],"sourcesContent":["import { isIPv4, isIPv6 } from '@chainsafe/is-ip'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nexport { isIP } from '@chainsafe/is-ip'\nexport const isV4 = isIPv4\nexport const isV6 = isIPv6\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L7\n// but with buf/offset args removed because we don't use them\nexport const toBytes = function (ip: string): Uint8Array {\n  let offset = 0\n  ip = ip.toString().trim()\n\n  if (isV4(ip)) {\n    const bytes = new Uint8Array(offset + 4)\n\n    ip.split(/\\./g).forEach((byte) => {\n      bytes[offset++] = parseInt(byte, 10) & 0xff\n    })\n\n    return bytes\n  }\n\n  if (isV6(ip)) {\n    const sections = ip.split(':', 8)\n\n    let i\n    for (i = 0; i < sections.length; i++) {\n      const isv4 = isV4(sections[i])\n      let v4Buffer: Uint8Array | undefined\n\n      if (isv4) {\n        v4Buffer = toBytes(sections[i])\n        sections[i] = uint8ArrayToString(v4Buffer.slice(0, 2), 'base16')\n      }\n\n      if (v4Buffer != null && ++i < 8) {\n        sections.splice(i, 0, uint8ArrayToString(v4Buffer.slice(2, 4), 'base16'))\n      }\n    }\n\n    if (sections[0] === '') {\n      while (sections.length < 8) sections.unshift('0')\n    } else if (sections[sections.length - 1] === '') {\n      while (sections.length < 8) sections.push('0')\n    } else if (sections.length < 8) {\n      for (i = 0; i < sections.length && sections[i] !== ''; i++);\n      const argv: [number, number, ...string[]] = [i, 1]\n      for (i = 9 - sections.length; i > 0; i--) {\n        argv.push('0')\n      }\n      sections.splice.apply(sections, argv)\n    }\n\n    const bytes = new Uint8Array(offset + 16)\n\n    for (i = 0; i < sections.length; i++) {\n      const word = parseInt(sections[i], 16)\n      bytes[offset++] = (word >> 8) & 0xff\n      bytes[offset++] = word & 0xff\n    }\n\n    return bytes\n  }\n\n  throw new Error('invalid ip address')\n}\n\n// Copied from https://github.com/indutny/node-ip/blob/master/lib/ip.js#L63\nexport const toString = function (buf: Uint8Array, offset: number = 0, length?: number): string {\n  offset = ~~offset\n  length = length ?? (buf.length - offset)\n\n  const view = new DataView(buf.buffer)\n\n  if (length === 4) {\n    const result = []\n\n    // IPv4\n    for (let i = 0; i < length; i++) {\n      result.push(buf[offset + i])\n    }\n\n    return result.join('.')\n  }\n\n  if (length === 16) {\n    const result = []\n\n    // IPv6\n    for (let i = 0; i < length; i += 2) {\n      result.push(view.getUint16(offset + i).toString(16))\n    }\n\n    return result.join(':')\n      .replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')\n      .replace(/:{3,4}/, '::')\n  }\n\n  return ''\n}\n"]},"metadata":{},"sourceType":"module"}