{"ast":null,"code":"import { Token, Type } from './token.js';\nimport { assertEnoughData, decodeErrPrefix } from './common.js';\nimport * as uint from './0uint.js';\nimport { compare, fromString, slice } from './byte-utils.js';\n\nfunction toToken(data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length);\n  const buf = slice(data, pos + prefix, pos + prefix + length);\n  return new Token(Type.bytes, buf, prefix + length);\n}\n\nexport function decodeBytesCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeBytes8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeBytes16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeBytes32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeBytes64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);\n  }\n\n  return toToken(data, pos, 9, l);\n}\n\nfunction tokenBytes(token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value;\n  }\n\n  return token.encodedBytes;\n}\n\nexport function encodeBytes(buf, token) {\n  const bytes = tokenBytes(token);\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length);\n  buf.push(bytes);\n}\n\nencodeBytes.encodedSize = function encodedSize(token) {\n  const bytes = tokenBytes(token);\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length;\n};\n\nencodeBytes.compareTokens = function compareTokens(tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));\n};\n\nexport function compareBytes(b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);\n}","map":{"version":3,"sources":["/home/legasi/nft-marketplace/node_modules/cborg/esm/lib/2bytes.js"],"names":["Token","Type","assertEnoughData","decodeErrPrefix","uint","compare","fromString","slice","toToken","data","pos","prefix","length","buf","bytes","decodeBytesCompact","minor","_options","decodeBytes8","_minor","options","readUint8","decodeBytes16","readUint16","decodeBytes32","readUint32","decodeBytes64","l","readUint64","Error","tokenBytes","token","encodedBytes","undefined","type","string","value","encodeBytes","encodeUintValue","majorEncoded","push","encodedSize","compareTokens","tok1","tok2","compareBytes","b1","b2"],"mappings":"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","sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  assertEnoughData,\n  decodeErrPrefix\n} from './common.js';\nimport * as uint from './0uint.js';\nimport {\n  compare,\n  fromString,\n  slice\n} from './byte-utils.js';\nfunction toToken(data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length);\n  const buf = slice(data, pos + prefix, pos + prefix + length);\n  return new Token(Type.bytes, buf, prefix + length);\n}\nexport function decodeBytesCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeBytes8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeBytes16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeBytes32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeBytes64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer bytes lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nfunction tokenBytes(token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value;\n  }\n  return token.encodedBytes;\n}\nexport function encodeBytes(buf, token) {\n  const bytes = tokenBytes(token);\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length);\n  buf.push(bytes);\n}\nencodeBytes.encodedSize = function encodedSize(token) {\n  const bytes = tokenBytes(token);\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length;\n};\nencodeBytes.compareTokens = function compareTokens(tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));\n};\nexport function compareBytes(b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);\n}"]},"metadata":{},"sourceType":"module"}