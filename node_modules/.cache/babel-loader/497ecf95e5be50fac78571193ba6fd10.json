{"ast":null,"code":"import { multiaddr, protocols } from '@multiformats/multiaddr';\n\nfunction extractSNI(ma) {\n  let sniProtoCode;\n\n  try {\n    sniProtoCode = protocols('sni').code;\n  } catch (e) {\n    // No SNI protocol in multiaddr\n    return null;\n  }\n\n  for (const [proto, value] of ma) {\n    if (proto === sniProtoCode && value !== undefined) {\n      return value;\n    }\n  }\n\n  return null;\n}\n\nfunction hasTLS(ma) {\n  return ma.some(_ref => {\n    let [proto, _] = _ref;\n    return proto === protocols('tls').code;\n  });\n}\n\nfunction interpretNext(headProtoCode, headProtoVal, restMa) {\n  const interpreter = interpreters[protocols(headProtoCode).name];\n\n  if (interpreter === undefined) {\n    throw new Error(`Can't interpret protocol ${protocols(headProtoCode).name}`);\n  }\n\n  const restVal = interpreter(headProtoVal, restMa);\n\n  if (headProtoCode === protocols('ip6').code) {\n    return `[${restVal}]`;\n  }\n\n  return restVal;\n}\n\nconst interpreters = {\n  ip4: (value, restMa) => value,\n  ip6: (value, restMa) => {\n    if (restMa.length === 0) {\n      return value;\n    }\n\n    return `[${value}]`;\n  },\n  tcp: (value, restMa) => {\n    const tailProto = restMa.pop();\n\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n\n    return `tcp://${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}:${value}`;\n  },\n  udp: (value, restMa) => {\n    const tailProto = restMa.pop();\n\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n\n    return `udp://${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}:${value}`;\n  },\n  dnsaddr: (value, restMa) => value,\n  dns4: (value, restMa) => value,\n  dns6: (value, restMa) => value,\n  dns: (value, restMa) => value,\n  ipfs: (value, restMa) => {\n    const tailProto = restMa.pop();\n\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/ipfs/${value}`;\n  },\n  p2p: (value, restMa) => {\n    const tailProto = restMa.pop();\n\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p/${value}`;\n  },\n  http: (value, restMa) => {\n    const maHasTLS = hasTLS(restMa);\n    const sni = extractSNI(restMa);\n\n    if (maHasTLS && sni !== null) {\n      return `https://${sni}`;\n    }\n\n    const protocol = maHasTLS ? 'https://' : 'http://';\n    const tailProto = restMa.pop();\n\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa); // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n\n    baseVal = baseVal.replace('tcp://', '');\n    return `${protocol}${baseVal}`;\n  },\n  tls: (value, restMa) => {\n    // Noop, the parent context knows that it's tls. We don't need to do\n    // anything here\n    const tailProto = restMa.pop();\n\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n\n    return interpretNext(tailProto[0], tailProto[1] ?? '', restMa);\n  },\n  sni: (value, restMa) => {\n    // Noop, the parent context uses the sni information, we don't need to do\n    // anything here\n    const tailProto = restMa.pop();\n\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n\n    return interpretNext(tailProto[0], tailProto[1] ?? '', restMa);\n  },\n  https: (value, restMa) => {\n    const tailProto = restMa.pop();\n\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa); // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n\n    baseVal = baseVal.replace('tcp://', '');\n    return `https://${baseVal}`;\n  },\n  ws: (value, restMa) => {\n    const maHasTLS = hasTLS(restMa);\n    const sni = extractSNI(restMa);\n\n    if (maHasTLS && sni !== null) {\n      return `wss://${sni}`;\n    }\n\n    const protocol = maHasTLS ? 'wss://' : 'ws://';\n    const tailProto = restMa.pop();\n\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa); // We are reinterpreting the base, so we need to remove the tcp:// if it's there\n\n    baseVal = baseVal.replace('tcp://', '');\n    return `${protocol}${baseVal}`;\n  },\n  wss: (value, restMa) => {\n    const tailProto = restMa.pop();\n\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa); // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n\n    baseVal = baseVal.replace('tcp://', '');\n    return `wss://${baseVal}`;\n  },\n  'p2p-websocket-star': (value, restMa) => {\n    const tailProto = restMa.pop();\n\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-websocket-star`;\n  },\n  'p2p-webrtc-star': (value, restMa) => {\n    const tailProto = restMa.pop();\n\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-webrtc-star`;\n  },\n  'p2p-webrtc-direct': (value, restMa) => {\n    const tailProto = restMa.pop();\n\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-webrtc-direct`;\n  }\n};\nexport function multiaddrToUri(input, opts) {\n  const ma = multiaddr(input);\n  const parts = ma.stringTuples();\n  const head = parts.pop();\n\n  if (head === undefined) {\n    throw new Error('Unexpected end of multiaddr');\n  }\n\n  const protocol = protocols(head[0]);\n  const interpreter = interpreters[protocol.name];\n\n  if (interpreter == null) {\n    throw new Error(`No interpreter found for ${protocol.name}`);\n  }\n\n  let uri = interpreter(head[1] ?? '', parts);\n\n  if (opts?.assumeHttp !== false && head[0] === protocols('tcp').code) {\n    // If rightmost proto is tcp, we assume http here\n    uri = uri.replace('tcp://', 'http://');\n\n    if (head[1] === '443' || head[1] === '80') {\n      if (head[1] === '443') {\n        uri = uri.replace('http://', 'https://');\n      } // Drop the port\n\n\n      uri = uri.substring(0, uri.lastIndexOf(':'));\n    }\n  }\n\n  return uri;\n}","map":{"version":3,"mappings":"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","names":["multiaddr","protocols","extractSNI","ma","sniProtoCode","code","e","proto","value","undefined","hasTLS","some","_","interpretNext","headProtoCode","headProtoVal","restMa","interpreter","interpreters","name","Error","restVal","ip4","ip6","length","tcp","tailProto","pop","udp","dnsaddr","dns4","dns6","dns","ipfs","p2p","http","maHasTLS","sni","protocol","baseVal","replace","tls","https","ws","wss","multiaddrToUri","input","opts","parts","stringTuples","head","uri","assumeHttp","substring","lastIndexOf"],"sources":["/home/legasi/nft-marketplace/node_modules/@multiformats/multiaddr-to-uri/src/index.ts"],"sourcesContent":["import { multiaddr, protocols } from '@multiformats/multiaddr'\nimport type { Multiaddr, StringTuple } from '@multiformats/multiaddr'\n\nexport interface MultiaddrToUriOpts {\n  assumeHttp?: boolean\n}\n\ninterface Interpreter { (value: string, ma: StringTuple[]): string }\n\nfunction extractSNI (ma: StringTuple[]): string | null {\n  let sniProtoCode: number\n  try {\n    sniProtoCode = protocols('sni').code\n  } catch (e) {\n    // No SNI protocol in multiaddr\n    return null\n  }\n  for (const [proto, value] of ma) {\n    if (proto === sniProtoCode && value !== undefined) {\n      return value\n    }\n  }\n  return null\n}\n\nfunction hasTLS (ma: StringTuple[]): boolean {\n  return ma.some(([proto, _]) => proto === protocols('tls').code)\n}\n\nfunction interpretNext (headProtoCode: number, headProtoVal: string, restMa: StringTuple[]): string {\n  const interpreter = interpreters[protocols(headProtoCode).name]\n  if (interpreter === undefined) {\n    throw new Error(`Can't interpret protocol ${protocols(headProtoCode).name}`)\n  }\n  const restVal = interpreter(headProtoVal, restMa)\n  if (headProtoCode === protocols('ip6').code) {\n    return `[${restVal}]`\n  }\n  return restVal\n}\n\nconst interpreters: Record<string, Interpreter> = {\n  ip4: (value: string, restMa: StringTuple[]) => value,\n  ip6: (value: string, restMa: StringTuple[]) => {\n    if (restMa.length === 0) {\n      return value\n    }\n    return `[${value}]`\n  },\n  tcp: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `tcp://${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}:${value}`\n  },\n  udp: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `udp://${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}:${value}`\n  },\n  dnsaddr: (value: string, restMa: StringTuple[]) => value,\n  dns4: (value: string, restMa: StringTuple[]) => value,\n  dns6: (value: string, restMa: StringTuple[]) => value,\n  dns: (value: string, restMa: StringTuple[]) => value,\n  ipfs: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/ipfs/${value}`\n  },\n  p2p: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p/${value}`\n  },\n  http: (value: string, restMa: StringTuple[]) => {\n    const maHasTLS = hasTLS(restMa)\n    const sni = extractSNI(restMa)\n    if (maHasTLS && sni !== null) {\n      return `https://${sni}`\n    }\n    const protocol = maHasTLS ? 'https://' : 'http://'\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '')\n    return `${protocol}${baseVal}`\n  },\n  tls: (value: string, restMa: StringTuple[]) => {\n    // Noop, the parent context knows that it's tls. We don't need to do\n    // anything here\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n  },\n  sni: (value: string, restMa: StringTuple[]) => {\n    // Noop, the parent context uses the sni information, we don't need to do\n    // anything here\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n  },\n  https: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '')\n    return `https://${baseVal}`\n  },\n  ws: (value: string, restMa: StringTuple[]) => {\n    const maHasTLS = hasTLS(restMa)\n    const sni = extractSNI(restMa)\n    if (maHasTLS && sni !== null) {\n      return `wss://${sni}`\n    }\n    const protocol = maHasTLS ? 'wss://' : 'ws://'\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n    // We are reinterpreting the base, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '')\n    return `${protocol}${baseVal}`\n  },\n  wss: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '')\n    return `wss://${baseVal}`\n  },\n  'p2p-websocket-star': (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-websocket-star`\n  },\n  'p2p-webrtc-star': (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-webrtc-star`\n  },\n  'p2p-webrtc-direct': (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-webrtc-direct`\n  }\n}\n\nexport function multiaddrToUri (input: Multiaddr | string | Uint8Array, opts?: MultiaddrToUriOpts): string {\n  const ma = multiaddr(input)\n  const parts = ma.stringTuples()\n  const head = parts.pop()\n  if (head === undefined) {\n    throw new Error('Unexpected end of multiaddr')\n  }\n\n  const protocol = protocols(head[0])\n  const interpreter = interpreters[protocol.name]\n\n  if (interpreter == null) {\n    throw new Error(`No interpreter found for ${protocol.name}`)\n  }\n\n  let uri = interpreter(head[1] ?? '', parts)\n  if (opts?.assumeHttp !== false && head[0] === protocols('tcp').code) {\n    // If rightmost proto is tcp, we assume http here\n    uri = uri.replace('tcp://', 'http://')\n    if (head[1] === '443' || head[1] === '80') {\n      if (head[1] === '443') {\n        uri = uri.replace('http://', 'https://')\n      }\n      // Drop the port\n      uri = uri.substring(0, uri.lastIndexOf(':'))\n    }\n  }\n\n  return uri\n}\n"]},"metadata":{},"sourceType":"module"}