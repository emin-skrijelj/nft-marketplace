{"ast":null,"code":"import { is } from './is.js';\nimport { Token, Type } from './token.js';\nimport { Bl } from './bl.js';\nimport { encodeErrPrefix } from './common.js';\nimport { quickEncodeToken } from './jump.js';\nimport { asU8A } from './byte-utils.js';\nimport { encodeUint } from './0uint.js';\nimport { encodeNegint } from './1negint.js';\nimport { encodeBytes } from './2bytes.js';\nimport { encodeString } from './3string.js';\nimport { encodeArray } from './4array.js';\nimport { encodeMap } from './5map.js';\nimport { encodeTag } from './6tag.js';\nimport { encodeFloat } from './7float.js';\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n};\nexport function makeCborEncoders() {\n  const encoders = [];\n  encoders[Type.uint.major] = encodeUint;\n  encoders[Type.negint.major] = encodeNegint;\n  encoders[Type.bytes.major] = encodeBytes;\n  encoders[Type.string.major] = encodeString;\n  encoders[Type.array.major] = encodeArray;\n  encoders[Type.map.major] = encodeMap;\n  encoders[Type.tag.major] = encodeTag;\n  encoders[Type.float.major] = encodeFloat;\n  return encoders;\n}\nconst cborEncoders = makeCborEncoders();\nconst buf = new Bl();\n\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n\n  includes(obj) {\n    let p = this;\n\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n\n    return false;\n  }\n\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${encodeErrPrefix} object contains circular references`);\n    }\n\n    return new Ref(obj, stack);\n  }\n\n}\n\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj);\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj);\n  },\n\n  string(obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj);\n  },\n\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj));\n  },\n\n  DataView(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new Token(Type.break)];\n      }\n\n      return simpleTokens.emptyArray;\n    }\n\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n\n    if (options.addBreakTokens) {\n      return [new Token(Type.array, obj.length), entries, new Token(Type.break)];\n    }\n\n    return [new Token(Type.array, obj.length), entries];\n  },\n\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new Token(Type.break)];\n      }\n\n      return simpleTokens.emptyMap;\n    }\n\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n\n    for (const key of keys) {\n      entries[i++] = [objectToTokens(key, options, refStack), objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)];\n    }\n\n    sortMapEntries(entries, options);\n\n    if (options.addBreakTokens) {\n      return [new Token(Type.map, length), entries, new Token(Type.break)];\n    }\n\n    return [new Token(Type.map, length), entries];\n  }\n\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\n\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${typ}Array`] = typeEncoders.DataView;\n}\n\nfunction objectToTokens(obj) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let refStack = arguments.length > 2 ? arguments[2] : undefined;\n  const typ = is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n\n  const typeEncoder = typeEncoders[typ];\n\n  if (!typeEncoder) {\n    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);\n  }\n\n  return typeEncoder(obj, typ, options, refStack);\n}\n\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\n\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n\n  return tcmp;\n}\n\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\n\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n\n    if (quickBytes) {\n      return quickBytes;\n    }\n\n    const encoder = encoders[tokens.type.major];\n\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new Bl(size);\n      encoder(buf, tokens, options);\n\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);\n      }\n\n      return asU8A(buf.chunks[0]);\n    }\n  }\n\n  buf.reset();\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\n\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\n\nexport { objectToTokens, encode, encodeCustom, Ref };","map":{"version":3,"sources":["/home/legasi/nft-marketplace/node_modules/cborg/esm/lib/encode.js"],"names":["is","Token","Type","Bl","encodeErrPrefix","quickEncodeToken","asU8A","encodeUint","encodeNegint","encodeBytes","encodeString","encodeArray","encodeMap","encodeTag","encodeFloat","defaultEncodeOptions","float64","mapSorter","makeCborEncoders","encoders","uint","major","negint","bytes","string","array","map","tag","float","cborEncoders","buf","Ref","constructor","obj","parent","includes","p","createCheck","stack","Error","simpleTokens","null","undefined","true","false","emptyArray","emptyMap","typeEncoders","number","_typ","_options","_refStack","Number","isInteger","isSafeInteger","bigint","BigInt","Uint8Array","boolean","_obj","ArrayBuffer","DataView","buffer","byteOffset","byteLength","Array","options","refStack","length","addBreakTokens","break","entries","i","e","objectToTokens","Object","typ","isMap","keys","size","key","get","sortMapEntries","Map","Buffer","split","customTypeEncoder","tokens","typeEncoder","sort","e1","e2","keyToken1","isArray","keyToken2","type","compare","tcmp","compareTokens","console","warn","tokensToEncoded","token","encodeCustom","data","quickBytes","encoder","encodedSize","chunks","reset","toBytes","encode","assign"],"mappings":"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","sourcesContent":["import { is } from './is.js';\nimport {\n  Token,\n  Type\n} from './token.js';\nimport { Bl } from './bl.js';\nimport { encodeErrPrefix } from './common.js';\nimport { quickEncodeToken } from './jump.js';\nimport { asU8A } from './byte-utils.js';\nimport { encodeUint } from './0uint.js';\nimport { encodeNegint } from './1negint.js';\nimport { encodeBytes } from './2bytes.js';\nimport { encodeString } from './3string.js';\nimport { encodeArray } from './4array.js';\nimport { encodeMap } from './5map.js';\nimport { encodeTag } from './6tag.js';\nimport { encodeFloat } from './7float.js';\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n};\nexport function makeCborEncoders() {\n  const encoders = [];\n  encoders[Type.uint.major] = encodeUint;\n  encoders[Type.negint.major] = encodeNegint;\n  encoders[Type.bytes.major] = encodeBytes;\n  encoders[Type.string.major] = encodeString;\n  encoders[Type.array.major] = encodeArray;\n  encoders[Type.map.major] = encodeMap;\n  encoders[Type.tag.major] = encodeTag;\n  encoders[Type.float.major] = encodeFloat;\n  return encoders;\n}\nconst cborEncoders = makeCborEncoders();\nconst buf = new Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${ encodeErrPrefix } object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj);\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyArray,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.array, obj.length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.array, obj.length),\n      entries\n    ];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyMap,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.map, length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.map, length),\n      entries\n    ];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${ typ }Array`] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj, options = {}, refStack) {\n  const typ = is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${ encodeErrPrefix } unsupported type: ${ typ }`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${ tokens } was wrong`);\n      }\n      return asU8A(buf.chunks[0]);\n    }\n  }\n  buf.reset();\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\nexport {\n  objectToTokens,\n  encode,\n  encodeCustom,\n  Ref\n};"]},"metadata":{},"sourceType":"module"}