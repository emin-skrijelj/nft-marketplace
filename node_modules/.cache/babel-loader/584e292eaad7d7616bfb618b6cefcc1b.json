{"ast":null,"code":"/**\n * @typedef {import('@libp2p/interface-pubsub').Message} Message\n * @typedef {import('@libp2p/interfaces/events').EventHandler<Message>} MessageHandlerFn\n *\n * @typedef {object} Subscription\n * @property {MessageHandlerFn} handler\n * @property {AbortController} controller\n */\nexport class SubscriptionTracker {\n  constructor() {\n    /** @type {Map<string, Subscription[]>} */\n    this._subs = new Map();\n  }\n  /**\n   * @param {string} topic\n   * @param {MessageHandlerFn} handler\n   * @param {AbortSignal} [signal]\n   */\n\n\n  subscribe(topic, handler, signal) {\n    const topicSubs = this._subs.get(topic) || [];\n\n    if (topicSubs.find(s => s.handler === handler)) {\n      throw new Error(`Already subscribed to ${topic} with this handler`);\n    } // Create controller so a call to unsubscribe can cancel the request\n\n\n    const controller = new AbortController();\n\n    this._subs.set(topic, [{\n      handler,\n      controller\n    }].concat(topicSubs)); // If there is an external signal, forward the abort event\n\n\n    if (signal) {\n      signal.addEventListener('abort', () => this.unsubscribe(topic, handler));\n    }\n\n    return controller.signal;\n  }\n  /**\n   * @param {string} topic\n   * @param {MessageHandlerFn} [handler]\n   */\n\n\n  unsubscribe(topic, handler) {\n    const subs = this._subs.get(topic) || [];\n    let unsubs;\n\n    if (handler) {\n      this._subs.set(topic, subs.filter(s => s.handler !== handler));\n\n      unsubs = subs.filter(s => s.handler === handler);\n    } else {\n      this._subs.set(topic, []);\n\n      unsubs = subs;\n    }\n\n    if (!(this._subs.get(topic) || []).length) {\n      this._subs.delete(topic);\n    }\n\n    unsubs.forEach(s => s.controller.abort());\n  }\n\n}","map":{"version":3,"sources":["/home/legasi/nft-marketplace/node_modules/ipfs-http-client/src/pubsub/subscription-tracker.js"],"names":["SubscriptionTracker","constructor","_subs","Map","subscribe","topic","handler","signal","topicSubs","get","find","s","Error","controller","AbortController","set","concat","addEventListener","unsubscribe","subs","unsubs","filter","length","delete","forEach","abort"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAO,MAAMA,mBAAN,CAA0B;AAC/BC,EAAAA,WAAW,GAAI;AACb;AACA,SAAKC,KAAL,GAAa,IAAIC,GAAJ,EAAb;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEC,EAAAA,SAAS,CAAEC,KAAF,EAASC,OAAT,EAAkBC,MAAlB,EAA0B;AACjC,UAAMC,SAAS,GAAG,KAAKN,KAAL,CAAWO,GAAX,CAAeJ,KAAf,KAAyB,EAA3C;;AAEA,QAAIG,SAAS,CAACE,IAAV,CAAeC,CAAC,IAAIA,CAAC,CAACL,OAAF,KAAcA,OAAlC,CAAJ,EAAgD;AAC9C,YAAM,IAAIM,KAAJ,CAAW,yBAAwBP,KAAM,oBAAzC,CAAN;AACD,KALgC,CAOjC;;;AACA,UAAMQ,UAAU,GAAG,IAAIC,eAAJ,EAAnB;;AAEA,SAAKZ,KAAL,CAAWa,GAAX,CAAeV,KAAf,EAAsB,CAAC;AAAEC,MAAAA,OAAF;AAAWO,MAAAA;AAAX,KAAD,EAA0BG,MAA1B,CAAiCR,SAAjC,CAAtB,EAViC,CAYjC;;;AACA,QAAID,MAAJ,EAAY;AACVA,MAAAA,MAAM,CAACU,gBAAP,CAAwB,OAAxB,EAAiC,MAAM,KAAKC,WAAL,CAAiBb,KAAjB,EAAwBC,OAAxB,CAAvC;AACD;;AAED,WAAOO,UAAU,CAACN,MAAlB;AACD;AAED;AACF;AACA;AACA;;;AACEW,EAAAA,WAAW,CAAEb,KAAF,EAASC,OAAT,EAAkB;AAC3B,UAAMa,IAAI,GAAG,KAAKjB,KAAL,CAAWO,GAAX,CAAeJ,KAAf,KAAyB,EAAtC;AACA,QAAIe,MAAJ;;AAEA,QAAId,OAAJ,EAAa;AACX,WAAKJ,KAAL,CAAWa,GAAX,CAAeV,KAAf,EAAsBc,IAAI,CAACE,MAAL,CAAYV,CAAC,IAAIA,CAAC,CAACL,OAAF,KAAcA,OAA/B,CAAtB;;AACAc,MAAAA,MAAM,GAAGD,IAAI,CAACE,MAAL,CAAYV,CAAC,IAAIA,CAAC,CAACL,OAAF,KAAcA,OAA/B,CAAT;AACD,KAHD,MAGO;AACL,WAAKJ,KAAL,CAAWa,GAAX,CAAeV,KAAf,EAAsB,EAAtB;;AACAe,MAAAA,MAAM,GAAGD,IAAT;AACD;;AAED,QAAI,CAAC,CAAC,KAAKjB,KAAL,CAAWO,GAAX,CAAeJ,KAAf,KAAyB,EAA1B,EAA8BiB,MAAnC,EAA2C;AACzC,WAAKpB,KAAL,CAAWqB,MAAX,CAAkBlB,KAAlB;AACD;;AAEDe,IAAAA,MAAM,CAACI,OAAP,CAAeb,CAAC,IAAIA,CAAC,CAACE,UAAF,CAAaY,KAAb,EAApB;AACD;;AApD8B","sourcesContent":["\n/**\n * @typedef {import('@libp2p/interface-pubsub').Message} Message\n * @typedef {import('@libp2p/interfaces/events').EventHandler<Message>} MessageHandlerFn\n *\n * @typedef {object} Subscription\n * @property {MessageHandlerFn} handler\n * @property {AbortController} controller\n */\n\nexport class SubscriptionTracker {\n  constructor () {\n    /** @type {Map<string, Subscription[]>} */\n    this._subs = new Map()\n  }\n\n  /**\n   * @param {string} topic\n   * @param {MessageHandlerFn} handler\n   * @param {AbortSignal} [signal]\n   */\n  subscribe (topic, handler, signal) {\n    const topicSubs = this._subs.get(topic) || []\n\n    if (topicSubs.find(s => s.handler === handler)) {\n      throw new Error(`Already subscribed to ${topic} with this handler`)\n    }\n\n    // Create controller so a call to unsubscribe can cancel the request\n    const controller = new AbortController()\n\n    this._subs.set(topic, [{ handler, controller }].concat(topicSubs))\n\n    // If there is an external signal, forward the abort event\n    if (signal) {\n      signal.addEventListener('abort', () => this.unsubscribe(topic, handler))\n    }\n\n    return controller.signal\n  }\n\n  /**\n   * @param {string} topic\n   * @param {MessageHandlerFn} [handler]\n   */\n  unsubscribe (topic, handler) {\n    const subs = this._subs.get(topic) || []\n    let unsubs\n\n    if (handler) {\n      this._subs.set(topic, subs.filter(s => s.handler !== handler))\n      unsubs = subs.filter(s => s.handler === handler)\n    } else {\n      this._subs.set(topic, [])\n      unsubs = subs\n    }\n\n    if (!(this._subs.get(topic) || []).length) {\n      this._subs.delete(topic)\n    }\n\n    unsubs.forEach(s => s.controller.abort())\n  }\n}\n"]},"metadata":{},"sourceType":"module"}