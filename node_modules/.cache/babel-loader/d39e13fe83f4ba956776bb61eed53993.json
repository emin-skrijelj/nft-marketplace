{"ast":null,"code":"import * as varint from './varint.js';\nimport * as Digest from './hashes/digest.js';\nimport { base58btc } from './bases/base58.js';\nimport { base32 } from './bases/base32.js';\nimport { coerce } from './bytes.js'; // Linter can see that API is used in types.\n// eslint-disable-next-line\n\nimport * as API from \"./link/interface.js\"; // This way TS will also expose all the types from module\n\nexport * from './link/interface.js';\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\n\nexport const format = (link, base) => {\n  const {\n    bytes,\n    version\n  } = link;\n\n  switch (version) {\n    case 0:\n      return toStringV0(bytes, baseCache(link),\n      /** @type {API.MultibaseEncoder<\"z\">} */\n      base || base58btc.encoder);\n\n    default:\n      return toStringV1(bytes, baseCache(link),\n      /** @type {API.MultibaseEncoder<Prefix>} */\n      base || base32.encoder);\n  }\n};\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\n\nexport const toJSON = link => ({\n  '/': format(link)\n});\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\n\nexport const fromJSON = json => CID.parse(json['/']);\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\n\nconst cache = new WeakMap();\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\n\nconst baseCache = cid => {\n  const baseCache = cache.get(cid);\n\n  if (baseCache == null) {\n    const baseCache = new Map();\n    cache.set(cid, baseCache);\n    return baseCache;\n  }\n\n  return baseCache;\n};\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   *\n   */\n  constructor(version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code;\n    /** @readonly */\n\n    this.version = version;\n    /** @readonly */\n\n    this.multihash = multihash;\n    /** @readonly */\n\n    this.bytes = bytes; // flag to serializers that this is a CID and\n    // should be treated specially\n\n    /** @readonly */\n\n    this['/'] = bytes;\n  }\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n\n\n  get asCID() {\n    return this;\n  } // ArrayBufferView\n\n\n  get byteOffset() {\n    return this.bytes.byteOffset;\n  } // ArrayBufferView\n\n\n  get byteLength() {\n    return this.bytes.byteLength;\n  }\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n\n\n  toV0() {\n    switch (this.version) {\n      case 0:\n        {\n          return (\n            /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */\n            this\n          );\n        }\n\n      case 1:\n        {\n          const {\n            code,\n            multihash\n          } = this;\n\n          if (code !== DAG_PB_CODE) {\n            throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n          } // sha2-256\n\n\n          if (multihash.code !== SHA_256_CODE) {\n            throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n          }\n\n          return (\n            /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */\n            CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */\n            multihash)\n          );\n        }\n\n      default:\n        {\n          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);\n        }\n    }\n  }\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n\n\n  toV1() {\n    switch (this.version) {\n      case 0:\n        {\n          const {\n            code,\n            digest\n          } = this.multihash;\n          const multihash = Digest.create(code, digest);\n          return (\n            /** @type {CID<Data, Format, Alg, 1>} */\n            CID.createV1(this.code, multihash)\n          );\n        }\n\n      case 1:\n        {\n          return (\n            /** @type {CID<Data, Format, Alg, 1>} */\n            this\n          );\n        }\n\n      default:\n        {\n          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);\n        }\n    }\n  }\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n\n\n  equals(other) {\n    return CID.equals(this, other);\n  }\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n\n\n  static equals(self, other) {\n    const unknown =\n    /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */\n    other;\n    return unknown && self.code === unknown.code && self.version === unknown.version && Digest.equals(self.multihash, unknown.multihash);\n  }\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n\n\n  toString(base) {\n    return format(this, base);\n  }\n\n  toJSON() {\n    return {\n      '/': format(this)\n    };\n  }\n\n  link() {\n    return this;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'CID';\n  } // Legacy\n\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return `CID(${this.toString()})`;\n  }\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n\n\n  static asCID(input) {\n    if (input == null) {\n      return null;\n    }\n\n    const value =\n    /** @type {any} */\n    input;\n\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value;\n    } else if (value['/'] != null && value['/'] === value.bytes || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const {\n        version,\n        code,\n        multihash,\n        bytes\n      } = value;\n      return new CID(version, code,\n      /** @type {API.MultihashDigest<Alg>} */\n      multihash, bytes || encodeCID(version, code, multihash.bytes));\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const {\n        version,\n        multihash,\n        code\n      } = value;\n      const digest =\n      /** @type {API.MultihashDigest<Alg>} */\n      Digest.decode(multihash);\n      return CID.create(version, code, digest);\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null;\n    }\n  }\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n\n\n  static create(version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported');\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest');\n    }\n\n    switch (version) {\n      case 0:\n        {\n          if (code !== DAG_PB_CODE) {\n            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);\n          } else {\n            return new CID(version, code, digest, digest.bytes);\n          }\n        }\n\n      case 1:\n        {\n          const bytes = encodeCID(version, code, digest.bytes);\n          return new CID(version, code, digest, bytes);\n        }\n\n      default:\n        {\n          throw new Error('Invalid version');\n        }\n    }\n  }\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n\n\n  static createV0(digest) {\n    return CID.create(0, DAG_PB_CODE, digest);\n  }\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n\n\n  static createV1(code, digest) {\n    return CID.create(1, code, digest);\n  }\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n\n\n  static decode(bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes);\n\n    if (remainder.length) {\n      throw new Error('Incorrect length');\n    }\n\n    return cid;\n  }\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n\n\n  static decodeFirst(bytes) {\n    const specs = CID.inspectBytes(bytes);\n    const prefixSize = specs.size - specs.multihashSize;\n    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length');\n    }\n\n    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n    const digest = new Digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n    const cid = specs.version === 0 ? CID.createV0(\n    /** @type {API.MultihashDigest<API.SHA_256>} */\n    digest) : CID.createV1(specs.codec, digest);\n    return [\n    /** @type {CID<T, C, A, V>} */\n    cid, bytes.subarray(specs.size)];\n  }\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n\n\n  static inspectBytes(initialBytes) {\n    let offset = 0;\n\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset));\n      offset += length;\n      return i;\n    };\n\n    let version =\n    /** @type {V} */\n    next();\n    let codec =\n    /** @type {C} */\n    DAG_PB_CODE;\n\n    if (\n    /** @type {number} */\n    version === 18) {\n      // CIDv0\n      version =\n      /** @type {V} */\n      0;\n      offset = 0;\n    } else {\n      codec =\n      /** @type {C} */\n      next();\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`);\n    }\n\n    const prefixSize = offset;\n    const multihashCode =\n    /** @type {A} */\n    next(); // multihash code\n\n    const digestSize = next(); // multihash length\n\n    const size = offset + digestSize;\n    const multihashSize = size - prefixSize;\n    return {\n      version,\n      codec,\n      multihashCode,\n      digestSize,\n      multihashSize,\n      size\n    };\n  }\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n\n\n  static parse(source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base);\n    const cid = CID.decode(bytes);\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix');\n    } // Cache string representation to avoid computing it on `this.toString()`\n\n\n    baseCache(cid).set(prefix, source);\n    return cid;\n  }\n\n}\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\n\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q':\n      {\n        const decoder = base || base58btc;\n        return [\n        /** @type {Prefix} */\n        base58btc.prefix, decoder.decode(`${base58btc.prefix}${source}`)];\n      }\n\n    case base58btc.prefix:\n      {\n        const decoder = base || base58btc;\n        return [\n        /** @type {Prefix} */\n        base58btc.prefix, decoder.decode(source)];\n      }\n\n    case base32.prefix:\n      {\n        const decoder = base || base32;\n        return [\n        /** @type {Prefix} */\n        base32.prefix, decoder.decode(source)];\n      }\n\n    default:\n      {\n        if (base == null) {\n          throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n        }\n\n        return [\n        /** @type {Prefix} */\n        source[0], base.decode(source)];\n      }\n  }\n};\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\n\n\nconst toStringV0 = (bytes, cache, base) => {\n  const {\n    prefix\n  } = base;\n\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`);\n  }\n\n  const cid = cache.get(prefix);\n\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\n\n\nconst toStringV1 = (bytes, cache, base) => {\n  const {\n    prefix\n  } = base;\n  const cid = cache.get(prefix);\n\n  if (cid == null) {\n    const cid = base.encode(bytes);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\n\nconst DAG_PB_CODE = 0x70;\nconst SHA_256_CODE = 0x12;\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\n\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version);\n  const hashOffset = codeOffset + varint.encodingLength(code);\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n  varint.encodeTo(version, bytes, 0);\n  varint.encodeTo(code, bytes, codeOffset);\n  bytes.set(multihash, hashOffset);\n  return bytes;\n};\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');","map":{"version":3,"sources":["/home/legasi/nft-marketplace/node_modules/@ipld/dag-json/node_modules/multiformats/src/cid.js"],"names":["varint","Digest","base58btc","base32","coerce","API","format","link","base","bytes","version","toStringV0","baseCache","encoder","toStringV1","toJSON","fromJSON","json","CID","parse","cache","WeakMap","cid","get","Map","set","constructor","code","multihash","asCID","byteOffset","byteLength","toV0","DAG_PB_CODE","Error","SHA_256_CODE","createV0","toV1","digest","create","createV1","equals","other","self","unknown","toString","Symbol","toStringTag","for","input","value","encodeCID","cidSymbol","decode","Uint8Array","remainder","decodeFirst","length","specs","inspectBytes","prefixSize","size","multihashSize","multihashBytes","subarray","digestBytes","digestSize","multihashCode","codec","initialBytes","offset","next","i","RangeError","source","prefix","parseCIDtoBytes","decoder","name","encode","slice","codeOffset","encodingLength","hashOffset","encodeTo"],"mappings":"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","sourcesContent":["import * as varint from './varint.js'\nimport * as Digest from './hashes/digest.js'\nimport { base58btc } from './bases/base58.js'\nimport { base32 } from './bases/base32.js'\nimport { coerce } from './bytes.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   *\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n"]},"metadata":{},"sourceType":"module"}