{"ast":null,"code":"import * as cborg from 'cborg';\nimport { CID } from 'multiformats/cid'; // https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\n\nconst CID_CBOR_TAG = 42;\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal.\n *\n * @param {any} obj\n * @returns {cborg.Token[]|null}\n */\n\nfunction cidEncoder(obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null; // any other kind of object\n  }\n\n  const cid = CID.asCID(obj);\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n\n  if (!cid) {\n    return null;\n  }\n\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1);\n  bytes.set(cid.bytes, 1); // prefix is 0x00, for historical reasons\n\n  return [new cborg.Token(cborg.Type.tag, CID_CBOR_TAG), new cborg.Token(cborg.Type.bytes, bytes)];\n} // eslint-disable-next-line jsdoc/require-returns-check\n\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\n\n\nfunction undefinedEncoder() {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');\n}\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\n\n\nfunction numberEncoder(num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n\n  return null;\n}\n\nconst encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n};\n/**\n * @param {Uint8Array} bytes\n * @returns {CID}\n */\n\nfunction cidDecoder(bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00');\n  }\n\n  return CID.decode(bytes.subarray(1)); // ignore leading 0x00\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  coerceUndefinedToNull: true,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true,\n  // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n};\ndecodeOptions.tags[CID_CBOR_TAG] = cidDecoder;\nexport const name = 'dag-cbor';\nexport const code = 0x71;\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\n\nexport const encode = node => cborg.encode(node, encodeOptions);\n/**\n * @template T\n * @param {ByteView<T>} data\n * @returns {T}\n */\n\nexport const decode = data => cborg.decode(data, decodeOptions);","map":{"version":3,"sources":["/home/legasi/nft-marketplace/node_modules/@ipld/dag-cbor/src/index.js"],"names":["cborg","CID","CID_CBOR_TAG","cidEncoder","obj","asCID","bytes","cid","Uint8Array","byteLength","set","Token","Type","tag","undefinedEncoder","Error","numberEncoder","num","Number","isNaN","Infinity","encodeOptions","float64","typeEncoders","Object","undefined","number","cidDecoder","decode","subarray","decodeOptions","allowIndefinite","coerceUndefinedToNull","allowNaN","allowInfinity","allowBigInt","strict","useMaps","rejectDuplicateMapKeys","tags","name","code","encode","node","data"],"mappings":"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","sourcesContent":["import * as cborg from 'cborg'\nimport { CID } from 'multiformats/cid'\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal.\n *\n * @param {any} obj\n * @returns {cborg.Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1)\n  bytes.set(cid.bytes, 1) // prefix is 0x00, for historical reasons\n  return [\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\n    new cborg.Token(cborg.Type.bytes, bytes)\n  ]\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null\n}\n\nconst encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {CID}\n */\nfunction cidDecoder (bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00')\n  }\n  return CID.decode(bytes.subarray(1)) // ignore leading 0x00\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  coerceUndefinedToNull: true,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\ndecodeOptions.tags[CID_CBOR_TAG] = cidDecoder\n\nexport const name = 'dag-cbor'\nexport const code = 0x71\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborg.encode(node, encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => cborg.decode(data, decodeOptions)\n"]},"metadata":{},"sourceType":"module"}