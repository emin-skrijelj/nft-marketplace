{"ast":null,"code":"/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\nimport { IpNet } from '@chainsafe/netmask';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport varint from 'varint';\nimport * as ip from './ip.js';\nimport { getProtocol } from './protocols-table.js';\nconst ip4Protocol = getProtocol('ip4');\nconst ip6Protocol = getProtocol('ip6');\nconst ipcidrProtocol = getProtocol('ipcidr');\nexport function convert(proto, a) {\n  if (a instanceof Uint8Array) {\n    return convertToString(proto, a);\n  } else {\n    return convertToBytes(proto, a);\n  }\n}\n/**\n * Convert [code,Uint8Array] to string\n */\n\nexport function convertToString(proto, buf) {\n  const protocol = getProtocol(proto);\n\n  switch (protocol.code) {\n    case 4: // ipv4\n\n    case 41:\n      // ipv6\n      return bytes2ip(buf);\n\n    case 42:\n      // ipv6zone\n      return bytes2str(buf);\n\n    case 6: // tcp\n\n    case 273: // udp\n\n    case 33: // dccp\n\n    case 132:\n      // sctp\n      return bytes2port(buf).toString();\n\n    case 53: // dns\n\n    case 54: // dns4\n\n    case 55: // dns6\n\n    case 56: // dnsaddr\n\n    case 400: // unix\n\n    case 449: // sni\n\n    case 777:\n      // memory\n      return bytes2str(buf);\n\n    case 421:\n      // ipfs\n      return bytes2mh(buf);\n\n    case 444:\n      // onion\n      return bytes2onion(buf);\n\n    case 445:\n      // onion3\n      return bytes2onion(buf);\n\n    case 466:\n      // certhash\n      return bytes2mb(buf);\n\n    default:\n      return uint8ArrayToString(buf, 'base16');\n    // no clue. convert to hex\n  }\n}\nexport function convertToBytes(proto, str) {\n  const protocol = getProtocol(proto);\n\n  switch (protocol.code) {\n    case 4:\n      // ipv4\n      return ip2bytes(str);\n\n    case 41:\n      // ipv6\n      return ip2bytes(str);\n\n    case 42:\n      // ipv6zone\n      return str2bytes(str);\n\n    case 6: // tcp\n\n    case 273: // udp\n\n    case 33: // dccp\n\n    case 132:\n      // sctp\n      return port2bytes(parseInt(str, 10));\n\n    case 53: // dns\n\n    case 54: // dns4\n\n    case 55: // dns6\n\n    case 56: // dnsaddr\n\n    case 400: // unix\n\n    case 449: // sni\n\n    case 777:\n      // memory\n      return str2bytes(str);\n\n    case 421:\n      // ipfs\n      return mh2bytes(str);\n\n    case 444:\n      // onion\n      return onion2bytes(str);\n\n    case 445:\n      // onion3\n      return onion32bytes(str);\n\n    case 466:\n      // certhash\n      return mb2bytes(str);\n\n    default:\n      return uint8ArrayFromString(str, 'base16');\n    // no clue. convert from hex\n  }\n}\nexport function convertToIpNet(multiaddr) {\n  let mask;\n  let addr;\n  multiaddr.stringTuples().forEach(_ref => {\n    let [code, value] = _ref;\n\n    if (code === ip4Protocol.code || code === ip6Protocol.code) {\n      addr = value;\n    }\n\n    if (code === ipcidrProtocol.code) {\n      mask = value;\n    }\n  });\n\n  if (mask == null || addr == null) {\n    throw new Error('Invalid multiaddr');\n  }\n\n  return new IpNet(addr, mask);\n}\nconst decoders = Object.values(bases).map(c => c.decoder);\n\nconst anybaseDecoder = function () {\n  let acc = decoders[0].or(decoders[1]);\n  decoders.slice(2).forEach(d => acc = acc.or(d));\n  return acc;\n}();\n\nfunction ip2bytes(ipString) {\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address');\n  }\n\n  return ip.toBytes(ipString);\n}\n\nfunction bytes2ip(ipBuff) {\n  const ipString = ip.toString(ipBuff, 0, ipBuff.length);\n\n  if (ipString == null) {\n    throw new Error('ipBuff is required');\n  }\n\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address');\n  }\n\n  return ipString;\n}\n\nfunction port2bytes(port) {\n  const buf = new ArrayBuffer(2);\n  const view = new DataView(buf);\n  view.setUint16(0, port);\n  return new Uint8Array(buf);\n}\n\nfunction bytes2port(buf) {\n  const view = new DataView(buf.buffer);\n  return view.getUint16(buf.byteOffset);\n}\n\nfunction str2bytes(str) {\n  const buf = uint8ArrayFromString(str);\n  const size = Uint8Array.from(varint.encode(buf.length));\n  return uint8ArrayConcat([size, buf], size.length + buf.length);\n}\n\nfunction bytes2str(buf) {\n  const size = varint.decode(buf);\n  buf = buf.slice(varint.decode.bytes);\n\n  if (buf.length !== size) {\n    throw new Error('inconsistent lengths');\n  }\n\n  return uint8ArrayToString(buf);\n}\n\nfunction mh2bytes(hash) {\n  let mh;\n\n  if (hash[0] === 'Q' || hash[0] === '1') {\n    mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes;\n  } else {\n    mh = CID.parse(hash).multihash.bytes;\n  } // the address is a varint prefixed multihash string representation\n\n\n  const size = Uint8Array.from(varint.encode(mh.length));\n  return uint8ArrayConcat([size, mh], size.length + mh.length);\n}\n\nfunction mb2bytes(mbstr) {\n  const mb = anybaseDecoder.decode(mbstr);\n  const size = Uint8Array.from(varint.encode(mb.length));\n  return uint8ArrayConcat([size, mb], size.length + mb.length);\n}\n\nfunction bytes2mb(buf) {\n  const size = varint.decode(buf);\n  const hash = buf.slice(varint.decode.bytes);\n\n  if (hash.length !== size) {\n    throw new Error('inconsistent lengths');\n  }\n\n  return 'u' + uint8ArrayToString(hash, 'base64url');\n}\n/**\n * Converts bytes to bas58btc string\n */\n\n\nfunction bytes2mh(buf) {\n  const size = varint.decode(buf);\n  const address = buf.slice(varint.decode.bytes);\n\n  if (address.length !== size) {\n    throw new Error('inconsistent lengths');\n  }\n\n  return uint8ArrayToString(address, 'base58btc');\n}\n\nfunction onion2bytes(str) {\n  const addr = str.split(':');\n\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n  }\n\n  if (addr[0].length !== 16) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);\n  } // onion addresses do not include the multibase prefix, add it before decoding\n\n\n  const buf = base32.decode('b' + addr[0]); // onion port number\n\n  const port = parseInt(addr[1], 10);\n\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)');\n  }\n\n  const portBuf = port2bytes(port);\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\n\nfunction onion32bytes(str) {\n  const addr = str.split(':');\n\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n  }\n\n  if (addr[0].length !== 56) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);\n  } // onion addresses do not include the multibase prefix, add it before decoding\n\n\n  const buf = base32.decode(`b${addr[0]}`); // onion port number\n\n  const port = parseInt(addr[1], 10);\n\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)');\n  }\n\n  const portBuf = port2bytes(port);\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\n\nfunction bytes2onion(buf) {\n  const addrBytes = buf.slice(0, buf.length - 2);\n  const portBytes = buf.slice(buf.length - 2);\n  const addr = uint8ArrayToString(addrBytes, 'base32');\n  const port = bytes2port(portBytes);\n  return `${addr}:${port}`;\n}","map":{"version":3,"mappings":"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","names":["IpNet","base32","base58btc","bases","CID","Digest","concat","uint8ArrayConcat","fromString","uint8ArrayFromString","toString","uint8ArrayToString","varint","ip","getProtocol","ip4Protocol","ip6Protocol","ipcidrProtocol","convert","proto","a","Uint8Array","convertToString","convertToBytes","buf","protocol","code","bytes2ip","bytes2str","bytes2port","bytes2mh","bytes2onion","bytes2mb","str","ip2bytes","str2bytes","port2bytes","parseInt","mh2bytes","onion2bytes","onion32bytes","mb2bytes","convertToIpNet","multiaddr","mask","addr","stringTuples","forEach","value","Error","decoders","Object","values","map","c","decoder","anybaseDecoder","acc","or","slice","d","ipString","isIP","toBytes","ipBuff","length","port","ArrayBuffer","view","DataView","setUint16","buffer","getUint16","byteOffset","size","from","encode","decode","bytes","hash","mh","parse","multihash","mbstr","mb","address","split","join","portBuf","addrBytes","portBytes"],"sources":["/home/legasi/nft-marketplace/node_modules/@multiformats/multiaddr/src/convert.ts"],"sourcesContent":["/**\n * @packageDocumentation\n *\n * Provides methods for converting\n */\n\nimport { IpNet } from '@chainsafe/netmask'\nimport { base32 } from 'multiformats/bases/base32'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { bases } from 'multiformats/basics'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport varint from 'varint'\nimport * as ip from './ip.js'\nimport { getProtocol } from './protocols-table.js'\nimport type { Multiaddr } from './index.js'\n\nconst ip4Protocol = getProtocol('ip4')\nconst ip6Protocol = getProtocol('ip6')\nconst ipcidrProtocol = getProtocol('ipcidr')\n\n/**\n * converts (serializes) addresses\n */\nexport function convert (proto: string, a: string): Uint8Array\nexport function convert (proto: string, a: Uint8Array): string\nexport function convert (proto: string, a: string | Uint8Array): Uint8Array | string {\n  if (a instanceof Uint8Array) {\n    return convertToString(proto, a)\n  } else {\n    return convertToBytes(proto, a)\n  }\n}\n\n/**\n * Convert [code,Uint8Array] to string\n */\nexport function convertToString (proto: number | string, buf: Uint8Array): string {\n  const protocol = getProtocol(proto)\n  switch (protocol.code) {\n    case 4: // ipv4\n    case 41: // ipv6\n      return bytes2ip(buf)\n    case 42: // ipv6zone\n      return bytes2str(buf)\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return bytes2port(buf).toString()\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 449: // sni\n    case 777: // memory\n      return bytes2str(buf)\n\n    case 421: // ipfs\n      return bytes2mh(buf)\n    case 444: // onion\n      return bytes2onion(buf)\n    case 445: // onion3\n      return bytes2onion(buf)\n    case 466: // certhash\n      return bytes2mb(buf)\n    default:\n      return uint8ArrayToString(buf, 'base16') // no clue. convert to hex\n  }\n}\n\nexport function convertToBytes (proto: string | number, str: string): Uint8Array {\n  const protocol = getProtocol(proto)\n  switch (protocol.code) {\n    case 4: // ipv4\n      return ip2bytes(str)\n    case 41: // ipv6\n      return ip2bytes(str)\n    case 42: // ipv6zone\n      return str2bytes(str)\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return port2bytes(parseInt(str, 10))\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 449: // sni\n    case 777: // memory\n      return str2bytes(str)\n\n    case 421: // ipfs\n      return mh2bytes(str)\n    case 444: // onion\n      return onion2bytes(str)\n    case 445: // onion3\n      return onion32bytes(str)\n    case 466: // certhash\n      return mb2bytes(str)\n    default:\n      return uint8ArrayFromString(str, 'base16') // no clue. convert from hex\n  }\n}\n\nexport function convertToIpNet (multiaddr: Multiaddr): IpNet {\n  let mask: string | undefined\n  let addr: string | undefined\n  multiaddr.stringTuples().forEach(([code, value]) => {\n    if (code === ip4Protocol.code || code === ip6Protocol.code) {\n      addr = value\n    }\n    if (code === ipcidrProtocol.code) {\n      mask = value\n    }\n  })\n  if (mask == null || addr == null) {\n    throw new Error('Invalid multiaddr')\n  }\n  return new IpNet(addr, mask)\n}\n\nconst decoders = Object.values(bases).map((c) => c.decoder)\nconst anybaseDecoder = (function () {\n  let acc = decoders[0].or(decoders[1])\n  decoders.slice(2).forEach((d) => (acc = acc.or(d)))\n  return acc\n})()\n\nfunction ip2bytes (ipString: string): Uint8Array {\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ip.toBytes(ipString)\n}\n\nfunction bytes2ip (ipBuff: Uint8Array): string {\n  const ipString = ip.toString(ipBuff, 0, ipBuff.length)\n  if (ipString == null) {\n    throw new Error('ipBuff is required')\n  }\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ipString\n}\n\nfunction port2bytes (port: number): Uint8Array {\n  const buf = new ArrayBuffer(2)\n  const view = new DataView(buf)\n  view.setUint16(0, port)\n\n  return new Uint8Array(buf)\n}\n\nfunction bytes2port (buf: Uint8Array): number {\n  const view = new DataView(buf.buffer)\n  return view.getUint16(buf.byteOffset)\n}\n\nfunction str2bytes (str: string): Uint8Array {\n  const buf = uint8ArrayFromString(str)\n  const size = Uint8Array.from(varint.encode(buf.length))\n  return uint8ArrayConcat([size, buf], size.length + buf.length)\n}\n\nfunction bytes2str (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  buf = buf.slice(varint.decode.bytes)\n\n  if (buf.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return uint8ArrayToString(buf)\n}\n\nfunction mh2bytes (hash: string): Uint8Array {\n  let mh\n\n  if (hash[0] === 'Q' || hash[0] === '1') {\n    mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes\n  } else {\n    mh = CID.parse(hash).multihash.bytes\n  }\n\n  // the address is a varint prefixed multihash string representation\n  const size = Uint8Array.from(varint.encode(mh.length))\n  return uint8ArrayConcat([size, mh], size.length + mh.length)\n}\n\nfunction mb2bytes (mbstr: string): Uint8Array {\n  const mb = anybaseDecoder.decode(mbstr)\n  const size = Uint8Array.from(varint.encode(mb.length))\n  return uint8ArrayConcat([size, mb], size.length + mb.length)\n}\nfunction bytes2mb (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  const hash = buf.slice(varint.decode.bytes)\n\n  if (hash.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return 'u' + uint8ArrayToString(hash, 'base64url')\n}\n\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  const address = buf.slice(varint.decode.bytes)\n\n  if (address.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return uint8ArrayToString(address, 'base58btc')\n}\n\nfunction onion2bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n  if (addr[0].length !== 16) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`)\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode('b' + addr[0])\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2bytes(port)\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nfunction onion32bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n  if (addr[0].length !== 56) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`)\n  }\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode(`b${addr[0]}`)\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2bytes(port)\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nfunction bytes2onion (buf: Uint8Array): string {\n  const addrBytes = buf.slice(0, buf.length - 2)\n  const portBytes = buf.slice(buf.length - 2)\n  const addr = uint8ArrayToString(addrBytes, 'base32')\n  const port = bytes2port(portBytes)\n  return `${addr}:${port}`\n}\n"]},"metadata":{},"sourceType":"module"}