{"ast":null,"code":"import { Token, Type } from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\n\nfunction toToken(_data, _pos, prefix, length) {\n  return new Token(Type.map, length, prefix);\n}\n\nexport function decodeMapCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeMap8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeMap16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeMap32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeMap64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);\n  }\n\n  return toToken(data, pos, 9, l);\n}\nexport function decodeMapIndefinite(data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);\n  }\n\n  return toToken(data, pos, 1, Infinity);\n}\nexport function encodeMap(buf, token) {\n  uint.encodeUintValue(buf, Type.map.majorEncoded, token.value);\n}\nencodeMap.compareTokens = uint.encodeUint.compareTokens;\n\nencodeMap.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};","map":{"version":3,"sources":["/home/legasi/nft-marketplace/node_modules/cborg/esm/lib/5map.js"],"names":["Token","Type","uint","decodeErrPrefix","toToken","_data","_pos","prefix","length","map","decodeMapCompact","data","pos","minor","_options","decodeMap8","_minor","options","readUint8","decodeMap16","readUint16","decodeMap32","readUint32","decodeMap64","l","readUint64","Error","decodeMapIndefinite","allowIndefinite","Infinity","encodeMap","buf","token","encodeUintValue","majorEncoded","value","compareTokens","encodeUint","encodedSize"],"mappings":"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","sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nfunction toToken(_data, _pos, prefix, length) {\n  return new Token(Type.map, length, prefix);\n}\nexport function decodeMapCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeMap8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeMap16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeMap32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeMap64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer map lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nexport function decodeMapIndefinite(data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return toToken(data, pos, 1, Infinity);\n}\nexport function encodeMap(buf, token) {\n  uint.encodeUintValue(buf, Type.map.majorEncoded, token.value);\n}\nencodeMap.compareTokens = uint.encodeUint.compareTokens;\nencodeMap.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};"]},"metadata":{},"sourceType":"module"}