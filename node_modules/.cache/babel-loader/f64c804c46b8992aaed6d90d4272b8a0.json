{"ast":null,"code":"import { Token, Type } from './token.js';\nimport { decodeErrPrefix, assertEnoughData } from './common.js';\nexport const uintBoundaries = [24, 256, 65536, 4294967296, BigInt('18446744073709551616')];\nexport function readUint8(data, offset, options) {\n  assertEnoughData(data, offset, 1);\n  const value = data[offset];\n\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);\n  }\n\n  return value;\n}\nexport function readUint16(data, offset, options) {\n  assertEnoughData(data, offset, 2);\n  const value = data[offset] << 8 | data[offset + 1];\n\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);\n  }\n\n  return value;\n}\nexport function readUint32(data, offset, options) {\n  assertEnoughData(data, offset, 4);\n  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];\n\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);\n  }\n\n  return value;\n}\nexport function readUint64(data, offset, options) {\n  assertEnoughData(data, offset, 8);\n  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];\n  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);\n\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);\n  }\n\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value);\n  }\n\n  if (options.allowBigInt === true) {\n    return value;\n  }\n\n  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);\n}\nexport function decodeUint8(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);\n}\nexport function decodeUint16(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);\n}\nexport function decodeUint32(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);\n}\nexport function decodeUint64(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);\n}\nexport function encodeUint(buf, token) {\n  return encodeUintValue(buf, 0, token.value);\n}\nexport function encodeUintValue(buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint);\n    buf.push([major | nuint]);\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint);\n    buf.push([major | 24, nuint]);\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint);\n    buf.push([major | 25, nuint >>> 8, nuint & 255]);\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint);\n    buf.push([major | 26, nuint >>> 24 & 255, nuint >>> 16 & 255, nuint >>> 8 & 255, nuint & 255]);\n  } else {\n    const buint = BigInt(uint);\n\n    if (buint < uintBoundaries[4]) {\n      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0];\n      let lo = Number(buint & BigInt(4294967295));\n      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));\n      set[8] = lo & 255;\n      lo = lo >> 8;\n      set[7] = lo & 255;\n      lo = lo >> 8;\n      set[6] = lo & 255;\n      lo = lo >> 8;\n      set[5] = lo & 255;\n      set[4] = hi & 255;\n      hi = hi >> 8;\n      set[3] = hi & 255;\n      hi = hi >> 8;\n      set[2] = hi & 255;\n      hi = hi >> 8;\n      set[1] = hi & 255;\n      buf.push(set);\n    } else {\n      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);\n    }\n  }\n}\n\nencodeUint.encodedSize = function encodedSize(token) {\n  return encodeUintValue.encodedSize(token.value);\n};\n\nencodeUintValue.encodedSize = function encodedSize(uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1;\n  }\n\n  if (uint < uintBoundaries[1]) {\n    return 2;\n  }\n\n  if (uint < uintBoundaries[2]) {\n    return 3;\n  }\n\n  if (uint < uintBoundaries[3]) {\n    return 5;\n  }\n\n  return 9;\n};\n\nencodeUint.compareTokens = function compareTokens(tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;\n};","map":{"version":3,"sources":["/home/legasi/nft-marketplace/node_modules/cborg/esm/lib/0uint.js"],"names":["Token","Type","decodeErrPrefix","assertEnoughData","uintBoundaries","BigInt","readUint8","data","offset","options","value","strict","Error","readUint16","readUint32","readUint64","hi","lo","Number","MAX_SAFE_INTEGER","allowBigInt","decodeUint8","pos","_minor","uint","decodeUint16","decodeUint32","decodeUint64","encodeUint","buf","token","encodeUintValue","major","nuint","push","buint","set","encodedSize","compareTokens","tok1","tok2"],"mappings":"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","sourcesContent":["import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  decodeErrPrefix,\n  assertEnoughData\n} from './common.js';\nexport const uintBoundaries = [\n  24,\n  256,\n  65536,\n  4294967296,\n  BigInt('18446744073709551616')\n];\nexport function readUint8(data, offset, options) {\n  assertEnoughData(data, offset, 1);\n  const value = data[offset];\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint16(data, offset, options) {\n  assertEnoughData(data, offset, 2);\n  const value = data[offset] << 8 | data[offset + 1];\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint32(data, offset, options) {\n  assertEnoughData(data, offset, 4);\n  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint64(data, offset, options) {\n  assertEnoughData(data, offset, 8);\n  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];\n  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value);\n  }\n  if (options.allowBigInt === true) {\n    return value;\n  }\n  throw new Error(`${ decodeErrPrefix } integers outside of the safe integer range are not supported`);\n}\nexport function decodeUint8(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);\n}\nexport function decodeUint16(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);\n}\nexport function decodeUint32(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);\n}\nexport function decodeUint64(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);\n}\nexport function encodeUint(buf, token) {\n  return encodeUintValue(buf, 0, token.value);\n}\nexport function encodeUintValue(buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint);\n    buf.push([major | nuint]);\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 24,\n      nuint\n    ]);\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 25,\n      nuint >>> 8,\n      nuint & 255\n    ]);\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 26,\n      nuint >>> 24 & 255,\n      nuint >>> 16 & 255,\n      nuint >>> 8 & 255,\n      nuint & 255\n    ]);\n  } else {\n    const buint = BigInt(uint);\n    if (buint < uintBoundaries[4]) {\n      const set = [\n        major | 27,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n      ];\n      let lo = Number(buint & BigInt(4294967295));\n      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));\n      set[8] = lo & 255;\n      lo = lo >> 8;\n      set[7] = lo & 255;\n      lo = lo >> 8;\n      set[6] = lo & 255;\n      lo = lo >> 8;\n      set[5] = lo & 255;\n      set[4] = hi & 255;\n      hi = hi >> 8;\n      set[3] = hi & 255;\n      hi = hi >> 8;\n      set[2] = hi & 255;\n      hi = hi >> 8;\n      set[1] = hi & 255;\n      buf.push(set);\n    } else {\n      throw new Error(`${ decodeErrPrefix } encountered BigInt larger than allowable range`);\n    }\n  }\n}\nencodeUint.encodedSize = function encodedSize(token) {\n  return encodeUintValue.encodedSize(token.value);\n};\nencodeUintValue.encodedSize = function encodedSize(uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1;\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2;\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3;\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5;\n  }\n  return 9;\n};\nencodeUint.compareTokens = function compareTokens(tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;\n};"]},"metadata":{},"sourceType":"module"}